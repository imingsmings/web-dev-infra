{"version":3,"file":"static/js/68.4ff33657.chunk.js","mappings":"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","sources":["../../node_modules/rough-notation/lib/rough-notation.esm.js","../../node_modules/diff/lib/index.mjs"],"sourcesContent":["const t=\"http://www.w3.org/2000/svg\";class e{constructor(t){this.seed=t}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}function s(t,e,s,i,n){return{type:\"path\",ops:c(t,e,s,i,n)}}function i(t,e,i){const n=(t||[]).length;if(n>2){const s=[];for(let e=0;e<n-1;e++)s.push(...c(t[e][0],t[e][1],t[e+1][0],t[e+1][1],i));return e&&s.push(...c(t[n-1][0],t[n-1][1],t[0][0],t[0][1],i)),{type:\"path\",ops:s}}return 2===n?s(t[0][0],t[0][1],t[1][0],t[1][1],i):{type:\"path\",ops:[]}}function n(t,e,s,n,o){return function(t,e){return i(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function o(t,e,s,i,n){return function(t,e,s,i){const[n,o]=l(i.increment,t,e,i.rx,i.ry,1,i.increment*h(.1,h(.4,1,s),s),s);let r=f(n,null,s);if(!s.disableMultiStroke){const[n]=l(i.increment,t,e,i.rx,i.ry,1.5,0,s),o=f(n,null,s);r=r.concat(o)}return{estimatedPoints:o,opset:{type:\"path\",ops:r}}}(t,e,n,function(t,e,s){const i=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),n=Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*i),o=2*Math.PI/n;let r=Math.abs(t/2),h=Math.abs(e/2);const c=1-s.curveFitting;return r+=a(r*c,s),h+=a(h*c,s),{increment:o,rx:r,ry:h}}(s,i,n)).opset}function r(t){return t.randomizer||(t.randomizer=new e(t.seed||0)),t.randomizer.next()}function h(t,e,s,i=1){return s.roughness*i*(r(s)*(e-t)+t)}function a(t,e,s=1){return h(-t,t,e,s)}function c(t,e,s,i,n,o=!1){const r=o?n.disableMultiStrokeFill:n.disableMultiStroke,h=u(t,e,s,i,n,!0,!1);if(r)return h;const a=u(t,e,s,i,n,!0,!0);return h.concat(a)}function u(t,e,s,i,n,o,h){const c=Math.pow(t-s,2)+Math.pow(e-i,2),u=Math.sqrt(c);let f=1;f=u<200?1:u>500?.4:-.0016668*u+1.233334;let l=n.maxRandomnessOffset||0;l*l*100>c&&(l=u/10);const g=l/2,d=.2+.2*r(n);let p=n.bowing*n.maxRandomnessOffset*(i-e)/200,_=n.bowing*n.maxRandomnessOffset*(t-s)/200;p=a(p,n,f),_=a(_,n,f);const m=[],w=()=>a(g,n,f),v=()=>a(l,n,f);return o&&(h?m.push({op:\"move\",data:[t+w(),e+w()]}):m.push({op:\"move\",data:[t+a(l,n,f),e+a(l,n,f)]})),h?m.push({op:\"bcurveTo\",data:[p+t+(s-t)*d+w(),_+e+(i-e)*d+w(),p+t+2*(s-t)*d+w(),_+e+2*(i-e)*d+w(),s+w(),i+w()]}):m.push({op:\"bcurveTo\",data:[p+t+(s-t)*d+v(),_+e+(i-e)*d+v(),p+t+2*(s-t)*d+v(),_+e+2*(i-e)*d+v(),s+v(),i+v()]}),m}function f(t,e,s){const i=t.length,n=[];if(i>3){const o=[],r=1-s.curveTightness;n.push({op:\"move\",data:[t[1][0],t[1][1]]});for(let e=1;e+2<i;e++){const s=t[e];o[0]=[s[0],s[1]],o[1]=[s[0]+(r*t[e+1][0]-r*t[e-1][0])/6,s[1]+(r*t[e+1][1]-r*t[e-1][1])/6],o[2]=[t[e+1][0]+(r*t[e][0]-r*t[e+2][0])/6,t[e+1][1]+(r*t[e][1]-r*t[e+2][1])/6],o[3]=[t[e+1][0],t[e+1][1]],n.push({op:\"bcurveTo\",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]})}if(e&&2===e.length){const t=s.maxRandomnessOffset;n.push({op:\"lineTo\",data:[e[0]+a(t,s),e[1]+a(t,s)]})}}else 3===i?(n.push({op:\"move\",data:[t[1][0],t[1][1]]}),n.push({op:\"bcurveTo\",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===i&&n.push(...c(t[0][0],t[0][1],t[1][0],t[1][1],s));return n}function l(t,e,s,i,n,o,r,h){const c=[],u=[],f=a(.5,h)-Math.PI/2;u.push([a(o,h)+e+.9*i*Math.cos(f-t),a(o,h)+s+.9*n*Math.sin(f-t)]);for(let r=f;r<2*Math.PI+f-.01;r+=t){const t=[a(o,h)+e+i*Math.cos(r),a(o,h)+s+n*Math.sin(r)];c.push(t),u.push(t)}return u.push([a(o,h)+e+i*Math.cos(f+2*Math.PI+.5*r),a(o,h)+s+n*Math.sin(f+2*Math.PI+.5*r)]),u.push([a(o,h)+e+.98*i*Math.cos(f+r),a(o,h)+s+.98*n*Math.sin(f+r)]),u.push([a(o,h)+e+.9*i*Math.cos(f+.5*r),a(o,h)+s+.9*n*Math.sin(f+.5*r)]),[u,c]}function g(t,e){return{maxRandomnessOffset:2,roughness:\"highlight\"===t?3:1.5,bowing:1,stroke:\"#000\",strokeWidth:1.5,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:\"hachure\",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,combineNestedSvgPaths:!1,disableMultiStroke:\"double\"!==t,disableMultiStrokeFill:!1,seed:e}}function d(e,r,h,a,c,u){const f=[];let l=h.strokeWidth||2;const d=function(t){const e=t.padding;if(e||0===e){if(\"number\"==typeof e)return[e,e,e,e];if(Array.isArray(e)){const t=e;if(t.length)switch(t.length){case 4:return[...t];case 1:return[t[0],t[0],t[0],t[0]];case 2:return[...t,...t];case 3:return[...t,t[1]];default:return[t[0],t[1],t[2],t[3]]}}}return[5,5,5,5]}(h),p=void 0===h.animate||!!h.animate,_=h.iterations||2,m=h.rtl?1:0,w=g(\"single\",u);switch(h.type){case\"underline\":{const t=r.y+r.h+d[2];for(let e=m;e<_+m;e++)e%2?f.push(s(r.x+r.w,t,r.x,t,w)):f.push(s(r.x,t,r.x+r.w,t,w));break}case\"strike-through\":{const t=r.y+r.h/2;for(let e=m;e<_+m;e++)e%2?f.push(s(r.x+r.w,t,r.x,t,w)):f.push(s(r.x,t,r.x+r.w,t,w));break}case\"box\":{const t=r.x-d[3],e=r.y-d[0],s=r.w+(d[1]+d[3]),i=r.h+(d[0]+d[2]);for(let o=0;o<_;o++)f.push(n(t,e,s,i,w));break}case\"bracket\":{const t=Array.isArray(h.brackets)?h.brackets:h.brackets?[h.brackets]:[\"right\"],e=r.x-2*d[3],s=r.x+r.w+2*d[1],n=r.y-2*d[0],o=r.y+r.h+2*d[2];for(const h of t){let t;switch(h){case\"bottom\":t=[[e,r.y+r.h],[e,o],[s,o],[s,r.y+r.h]];break;case\"top\":t=[[e,r.y],[e,n],[s,n],[s,r.y]];break;case\"left\":t=[[r.x,n],[e,n],[e,o],[r.x,o]];break;case\"right\":t=[[r.x+r.w,n],[s,n],[s,o],[r.x+r.w,o]]}t&&f.push(i(t,!1,w))}break}case\"crossed-off\":{const t=r.x,e=r.y,i=t+r.w,n=e+r.h;for(let o=m;o<_+m;o++)o%2?f.push(s(i,n,t,e,w)):f.push(s(t,e,i,n,w));for(let o=m;o<_+m;o++)o%2?f.push(s(t,n,i,e,w)):f.push(s(i,e,t,n,w));break}case\"circle\":{const t=g(\"double\",u),e=r.w+(d[1]+d[3]),s=r.h+(d[0]+d[2]),i=r.x-d[3]+e/2,n=r.y-d[0]+s/2,h=Math.floor(_/2),a=_-2*h;for(let r=0;r<h;r++)f.push(o(i,n,e,s,t));for(let t=0;t<a;t++)f.push(o(i,n,e,s,w));break}case\"highlight\":{const t=g(\"highlight\",u);l=.95*r.h;const e=r.y+r.h/2;for(let i=m;i<_+m;i++)i%2?f.push(s(r.x+r.w,e,r.x,e,t)):f.push(s(r.x,e,r.x+r.w,e,t));break}}if(f.length){const s=function(t){const e=[];for(const s of t){let t=\"\";for(const i of s.ops){const s=i.data;switch(i.op){case\"move\":t.trim()&&e.push(t.trim()),t=`M${s[0]} ${s[1]} `;break;case\"bcurveTo\":t+=`C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;break;case\"lineTo\":t+=`L${s[0]} ${s[1]} `}}t.trim()&&e.push(t.trim())}return e}(f),i=[],n=[];let o=0;const r=(t,e,s)=>t.setAttribute(e,s);for(const a of s){const s=document.createElementNS(t,\"path\");if(r(s,\"d\",a),r(s,\"fill\",\"none\"),r(s,\"stroke\",h.color||\"currentColor\"),r(s,\"stroke-width\",\"\"+l),p){const t=s.getTotalLength();i.push(t),o+=t}e.appendChild(s),n.push(s)}if(p){let t=0;for(let e=0;e<n.length;e++){const s=n[e],r=i[e],h=o?c*(r/o):0,u=a+t,f=s.style;f.strokeDashoffset=\"\"+r,f.strokeDasharray=\"\"+r,f.animation=`rough-notation-dash ${h}ms ease-out ${u}ms forwards`,t+=h}}}}class p{constructor(t,e){this._state=\"unattached\",this._resizing=!1,this._seed=Math.floor(Math.random()*2**31),this._lastSizes=[],this._animationDelay=0,this._resizeListener=()=>{this._resizing||(this._resizing=!0,setTimeout(()=>{this._resizing=!1,\"showing\"===this._state&&this.haveRectsChanged()&&this.show()},400))},this._e=t,this._config=JSON.parse(JSON.stringify(e)),this.attach()}get animate(){return this._config.animate}set animate(t){this._config.animate=t}get animationDuration(){return this._config.animationDuration}set animationDuration(t){this._config.animationDuration=t}get iterations(){return this._config.iterations}set iterations(t){this._config.iterations=t}get color(){return this._config.color}set color(t){this._config.color!==t&&(this._config.color=t,this.refresh())}get strokeWidth(){return this._config.strokeWidth}set strokeWidth(t){this._config.strokeWidth!==t&&(this._config.strokeWidth=t,this.refresh())}get padding(){return this._config.padding}set padding(t){this._config.padding!==t&&(this._config.padding=t,this.refresh())}attach(){if(\"unattached\"===this._state&&this._e.parentElement){!function(){if(!window.__rno_kf_s){const t=window.__rno_kf_s=document.createElement(\"style\");t.textContent=\"@keyframes rough-notation-dash { to { stroke-dashoffset: 0; } }\",document.head.appendChild(t)}}();const e=this._svg=document.createElementNS(t,\"svg\");e.setAttribute(\"class\",\"rough-annotation\");const s=e.style;s.position=\"absolute\",s.top=\"0\",s.left=\"0\",s.overflow=\"visible\",s.pointerEvents=\"none\",s.width=\"100px\",s.height=\"100px\";const i=\"highlight\"===this._config.type;if(this._e.insertAdjacentElement(i?\"beforebegin\":\"afterend\",e),this._state=\"not-showing\",i){const t=window.getComputedStyle(this._e).position;(!t||\"static\"===t)&&(this._e.style.position=\"relative\")}this.attachListeners()}}detachListeners(){window.removeEventListener(\"resize\",this._resizeListener),this._ro&&this._ro.unobserve(this._e)}attachListeners(){this.detachListeners(),window.addEventListener(\"resize\",this._resizeListener,{passive:!0}),!this._ro&&\"ResizeObserver\"in window&&(this._ro=new window.ResizeObserver(t=>{for(const e of t)e.contentRect&&this._resizeListener()})),this._ro&&this._ro.observe(this._e)}haveRectsChanged(){if(this._lastSizes.length){const t=this.rects();if(t.length!==this._lastSizes.length)return!0;for(let e=0;e<t.length;e++)if(!this.isSameRect(t[e],this._lastSizes[e]))return!0}return!1}isSameRect(t,e){const s=(t,e)=>Math.round(t)===Math.round(e);return s(t.x,e.x)&&s(t.y,e.y)&&s(t.w,e.w)&&s(t.h,e.h)}isShowing(){return\"not-showing\"!==this._state}refresh(){this.isShowing()&&!this.pendingRefresh&&(this.pendingRefresh=Promise.resolve().then(()=>{this.isShowing()&&this.show(),delete this.pendingRefresh}))}show(){switch(this._state){case\"unattached\":break;case\"showing\":this.hide(),this._svg&&this.render(this._svg,!0);break;case\"not-showing\":this.attach(),this._svg&&this.render(this._svg,!1)}}hide(){if(this._svg)for(;this._svg.lastChild;)this._svg.removeChild(this._svg.lastChild);this._state=\"not-showing\"}remove(){this._svg&&this._svg.parentElement&&this._svg.parentElement.removeChild(this._svg),this._svg=void 0,this._state=\"unattached\",this.detachListeners()}render(t,e){let s=this._config;e&&(s=JSON.parse(JSON.stringify(this._config)),s.animate=!1);const i=this.rects();let n=0;i.forEach(t=>n+=t.w);const o=s.animationDuration||800;let r=0;for(let e=0;e<i.length;e++){const h=o*(i[e].w/n);d(t,i[e],s,r+this._animationDelay,h,this._seed),r+=h}this._lastSizes=i,this._state=\"showing\"}rects(){const t=[];if(this._svg)if(this._config.multiline){const e=this._e.getClientRects();for(let s=0;s<e.length;s++)t.push(this.svgRect(this._svg,e[s]))}else t.push(this.svgRect(this._svg,this._e.getBoundingClientRect()));return t}svgRect(t,e){const s=t.getBoundingClientRect(),i=e;return{x:(i.x||i.left)-(s.x||s.left),y:(i.y||i.top)-(s.y||s.top),w:i.width,h:i.height}}}function _(t,e){return new p(t,e)}function m(t){let e=0;for(const s of t){const t=s;t._animationDelay=e;e+=0===t.animationDuration?0:t.animationDuration||800}const s=[...t];return{show(){for(const t of s)t.show()},hide(){for(const t of s)t.hide()}}}export{_ as annotate,m as annotationGroup};\n","function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n"],"names":["t","e","constructor","this","seed","next","Math","imul","random","s","i","n","type","ops","c","length","push","o","l","increment","rx","ry","h","r","f","disableMultiStroke","concat","estimatedPoints","opset","sqrt","PI","pow","max","curveStepCount","abs","curveFitting","a","randomizer","arguments","undefined","roughness","disableMultiStrokeFill","u","maxRandomnessOffset","g","d","p","bowing","_","m","w","v","op","data","curveTightness","cos","sin","stroke","strokeWidth","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","combineNestedSvgPaths","padding","Array","isArray","animate","iterations","rtl","y","x","brackets","floor","trim","setAttribute","document","createElementNS","color","getTotalLength","appendChild","style","strokeDashoffset","strokeDasharray","animation","_state","_resizing","_seed","_lastSizes","_animationDelay","_resizeListener","setTimeout","haveRectsChanged","show","_e","_config","JSON","parse","stringify","attach","animationDuration","refresh","parentElement","window","__rno_kf_s","createElement","textContent","head","_svg","position","top","left","overflow","pointerEvents","width","height","insertAdjacentElement","getComputedStyle","attachListeners","detachListeners","removeEventListener","_ro","unobserve","addEventListener","passive","ResizeObserver","contentRect","observe","rects","isSameRect","round","isShowing","pendingRefresh","Promise","resolve","then","hide","render","lastChild","removeChild","remove","forEach","multiline","getClientRects","svgRect","getBoundingClientRect","Diff","buildValues","diff","components","newString","oldString","useLongestToken","componentPos","componentLen","newPos","oldPos","component","removed","value","join","slice","count","added","tmp","map","oldValue","lastComponent","equals","pop","prototype","options","callback","self","done","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","min","bestPath","extractCommon","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","path","pushComponent","exec","ret","last","commonCount","right","comparator","ignoreCase","toLowerCase","array","split","chars","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","diffWords","oldStr","newStr","ignoreWhitespace","test","tokens","splice","lineDiff","retLines","linesAndNewlines","line","newlineIsToken","sentenceDiff","cssDiff","_typeof","obj","Symbol","iterator","objectPrototypeToString","Object","toString","jsonDiff","canonicalize","stack","replacementStack","replacer","key","canonicalizedObj","call","toJSON","_key","sortedKeys","sort","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","replace","arrayDiff"],"sourceRoot":""}