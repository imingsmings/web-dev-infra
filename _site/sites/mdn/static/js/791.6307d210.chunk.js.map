{"version":3,"file":"static/js/791.6307d210.chunk.js","mappings":"0JAOO,IAAKA,EAAM,SAANA,GAAM,OAANA,EAAM,4BAANA,EAAM,8BAANA,CAAM,MAmBNC,EAAkB,SAAlBA,GAAkB,OAAlBA,EAAkB,kBAAlBA,EAAkB,YAAlBA,EAAkB,oBAAlBA,EAAkB,gBAAlBA,EAAkB,cAAlBA,CAAkB,MA4BvB,MAAMC,UAAqBC,EAAAA,GAMhCC,cACEC,MAAM,gBACNC,KAAKC,QAAQ,GAAGC,OAAO,CACrBC,OACE,mEACFC,YAAa,sBACbC,QAAS,mBACTC,cAAe,iDAEjBN,KAAKC,QAAQ,GAAGC,OAAO,CACrBK,qBAAsB,SAExBP,KAAKC,QAAQ,GAAGC,OAAO,CACrBC,OACE,8EAUN,EAGK,MAAMK,EAAY,IAAIZ,EAEtBa,eAAeC,IAGpB,aAFsBF,EAAUD,qBAAqBI,eAAeC,QAGvD,CACTC,MAAOlB,EAAmBmB,QAC1BC,MAAO,KACPC,OAAQ,KACRC,SAAU,KACVC,UAAW,IAAIC,KAGrB,C,2FClGO,MAAMC,EAMXtB,cACEE,KAAKqB,SAAWrB,KAAKsB,kBACrBtB,KAAKuB,YAAa,EAClBvB,KAAKwB,QAAU,KACfxB,KAAKyB,UAAY,KAEbzB,KAAKqB,SAASK,aAChB1B,KAAK2B,aAEH3B,KAAKqB,SAASO,QAChB5B,KAAK6B,oBACH7B,KAAKqB,SAASS,aAAepC,EAAAA,GAAOqC,aAAerC,EAAAA,GAAOsC,eAG5DhC,KAAKiC,sBAET,CAEAN,aACEO,QAAQC,IAAI,uBACRnC,KAAKwB,UACPY,aAAapC,KAAKwB,SAClBxB,KAAKwB,QAAU,MAEjBxB,KAAKqC,SACLrC,KAAKwB,QAAUc,YAAW,IAAMtC,KAAK2B,cAAc,KACrD,CAEAY,eAAeC,GACb,GACO,SADCA,EAAMC,KAAKC,KAEfR,QAAQC,IAAI,aAGZD,QAAQC,IAAI,kBAElB,CAEAQ,aACE,OAAOC,UAAUC,cAAcF,UACjC,CAEAG,iBAAwB,IAADC,EACJ,QAAjBA,EAAA/C,KAAK2C,oBAAY,IAAAI,GAAjBA,EAAmBC,YAAY,CAAEN,KAAM,kBACzC,CAEAL,SAAU,IAADY,EACU,QAAjBA,EAAAjD,KAAK2C,oBAAY,IAAAM,GAAjBA,EAAmBD,YAAY,CAAEN,KAAM,UACzC,CAEAQ,SAAgD,IAAzCR,EAA+BS,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KACvC,MAAM,2BAANG,OAAsC,OAAJZ,QAAI,IAAJA,EAAAA,EAAQhD,EAAAA,GAAOqC,aACnD,CAEAwB,yBACEX,UAAUC,cAAcW,iBAAiB,WAAYC,GACnDzD,KAAKuC,eAAekB,IAExB,CAEAhD,0BAA0BiC,GACpB,kBAAmBE,YAAc5C,KAAKuB,mBAClCqB,UAAUC,cAAca,SAAS1D,KAAKkD,OAAOR,GAAO,CACxDiB,MAAO,MAET3D,KAAKuB,YAAa,GAEpBvB,KAAKuD,wBACP,CAEAK,UACEpD,EAAAA,GAAUqD,QACZ,CAEApD,6BACE,GAAI,kBAAmBmC,UAAW,CAChC,MAAMkB,QAAqBlB,UAAUC,cAAckB,wBACjC,OAAZD,QAAY,IAAZA,OAAY,EAAZA,EAAcE,cACpBhE,KAAKuB,YAAa,CACpB,CACF,CAEA0C,gBAAgBxC,GACVzB,KAAKyB,YAAcA,GACrBS,QAAQC,IAAI,kCACZ+B,cAAclE,KAAKyB,WACnBzB,KAAKyB,UAAY,MACRA,IAAczB,KAAKyB,YAC5BS,QAAQC,IAAI,mCACZnC,KAAKyB,UAAY0C,aACf,SAAAC,EAAA,OAAuB,QAAvBA,EAAMpE,KAAK2C,oBAAY,IAAAyB,OAAA,EAAjBA,EAAmBpB,YAAY,CAAEN,KAAM,aAAc,GAC3D,KAGN,CAEAjC,eACE,aAAaC,EAAAA,EAAAA,KACf,CAEAY,kBACE,OAAO+C,EAAAA,EAAoBC,MAC7B,CAEA7D,yBACE8D,GAEA,MAAMC,EAAUxE,KAAKsB,kBAkCrB,OAhCKkD,EAAQ5C,SAAW2C,EAAa3C,eAC7B5B,KAAKiC,6BACLjC,KAAK6B,oBACT0C,EAAazC,cAAgB0C,EAAQ1C,aACjCpC,EAAAA,GAAOqC,aACPrC,EAAAA,GAAOsC,gBAGb,iBAAkBuC,GAClBC,EAAQ1C,eAAiByC,EAAazC,qBAEhC9B,KAAKiC,6BACLjC,KAAK6B,oBACT0C,EAAazC,aAAepC,EAAAA,GAAOqC,aAAerC,EAAAA,GAAOsC,gBAGzDwC,EAAQ5C,UAAoC,IAAzB2C,EAAa3C,eAC5B5B,KAAKiC,wBAGoB,IAA7BsC,EAAa7C,aAAyB1B,KAAKwB,SAC7CY,aAAapC,KAAKwB,SAClBxB,KAAKwB,QAAU,OAEc,IAA7B+C,EAAa7C,cACW,IAAxB8C,EAAQ9C,aAER1B,KAAK2B,aAGP3B,KAAKqB,SAAW,IAAIgD,EAAAA,EAAoB,IAAKG,KAAYD,IACzDvE,KAAKqB,SAASoD,QACPzE,KAAKqB,QACd,CAEAZ,mCACQT,KAAK0E,mBAAmB,IAAIL,EAAAA,EACpC,CAEA5D,cAAe,IAADkE,EACK,QAAjBA,EAAA3E,KAAK2C,oBAAY,IAAAgC,GAAjBA,EAAmB3B,YAAY,CAAEN,KAAM,SACzC,EASK,SAASkC,IAId,OAHKC,OAAOC,YACVD,OAAOC,UAAY,IAAI1D,GAElByD,OAAOC,SAChB,C","sources":["settings/db.ts","settings/mdn-worker.tsx"],"sourcesContent":["// WARNING - This file is duplicated at two locations:\n// - client/pwa/src/db.ts\n// - client/src/settings/db.ts\n// Until we find a solution, keep both files in sync.\n\nimport Dexie from \"dexie\";\n\nexport enum SwType {\n  PreferOnline = \"PreferOnline\",\n  PreferOffline = \"PreferOffline\",\n}\n\nexport interface PlusSettings {\n  col_in_search: boolean;\n}\n\nexport interface Whoami {\n  id?: number;\n  username: string;\n  is_authenticated: boolean;\n  email: string;\n  avatar_url: string;\n  is_subscriber: boolean;\n  settings: PlusSettings | null;\n}\n\nexport enum ContentStatusPhase {\n  INITIAL = \"initial\",\n  IDLE = \"idle\",\n  DOWNLOAD = \"download\",\n  UNPACK = \"unpack\",\n  CLEAR = \"clear\",\n}\n\nexport interface LocalContentStatus {\n  version: string;\n  date: string;\n}\n\nexport interface RemoteContentStatus {\n  date: string;\n  latest: string;\n  updates: [string];\n}\n\nexport interface ContentStatus {\n  id?: number;\n  phase: ContentStatusPhase;\n  local: LocalContentStatus | null;\n  remote: RemoteContentStatus | null;\n  progress: number | null;\n  timestamp: Date;\n}\n\nexport class MDNOfflineDB extends Dexie {\n  // Declare implicit table properties.\n  // (just to inform Typescript. Instantiated by Dexie in stores() method)\n  whoami!: Dexie.Table<Whoami, number>; // number = type of the primkey\n  contentStatusHistory!: Dexie.Table<ContentStatus, number>;\n\n  constructor() {\n    super(\"MDNOfflineDB\");\n    this.version(1).stores({\n      whoami:\n        \"++, username, is_authenticated, email, avatar_url, is_subscriber\",\n      collections: \"url, title, created\",\n      watched: \"url, title, path\",\n      notifications: \"id, title, text, url, created, read, starred\",\n    });\n    this.version(2).stores({\n      contentStatusHistory: \"++id\",\n    });\n    this.version(3).stores({\n      whoami:\n        \"++, username, is_authenticated, email, avatar_url, is_subscriber, settings\",\n    });\n    // We can drop the tables only after we stop using thing in the sw\n    /*\n    this.version(4).stores({\n      collections: null,\n      watched: null,\n      notifications: null,\n    });\n    */\n  }\n}\n\nexport const offlineDb = new MDNOfflineDB();\n\nexport async function getContentStatus(): Promise<ContentStatus> {\n  const current = await offlineDb.contentStatusHistory.toCollection().last();\n\n  return (\n    current || {\n      phase: ContentStatusPhase.INITIAL,\n      local: null,\n      remote: null,\n      progress: null,\n      timestamp: new Date(),\n    }\n  );\n}\n\nexport async function patchContentStatus(\n  changes: Omit<Partial<ContentStatus>, \"id\" | \"timestamp\">\n) {\n  const db = offlineDb;\n  const table = db.contentStatusHistory;\n\n  await db.transaction(\"rw\", table, async () => {\n    const oldStatus = await getContentStatus();\n    const newStatus = {\n      ...oldStatus,\n      ...changes,\n      id: undefined,\n      timestamp: new Date(),\n    };\n\n    if (oldStatus.phase === ContentStatusPhase.INITIAL && !changes.phase) {\n      newStatus.phase = ContentStatusPhase.IDLE;\n    }\n\n    if (oldStatus.id && oldStatus.phase === newStatus.phase) {\n      await table.update(oldStatus.id, newStatus);\n    } else {\n      await table.add(newStatus);\n      // Keep latest entries for debugging.\n      await table.reverse().offset(100).delete();\n    }\n  });\n}\n","import { OfflineSettingsData } from \"../user-context\";\nimport { getContentStatus, SwType, offlineDb } from \"./db\";\n\nexport class MDNWorker {\n  settings: OfflineSettingsData;\n  registered: boolean;\n  timeout?: ReturnType<typeof setTimeout> | null;\n  keepAlive: ReturnType<typeof setInterval> | null;\n\n  constructor() {\n    this.settings = this.offlineSettings();\n    this.registered = false;\n    this.timeout = null;\n    this.keepAlive = null;\n\n    if (this.settings.autoUpdates) {\n      this.autoUpdate();\n    }\n    if (this.settings.offline) {\n      this.enableServiceWorker(\n        this.settings.preferOnline ? SwType.PreferOnline : SwType.PreferOffline\n      );\n    } else {\n      this.disableServiceWorker();\n    }\n  }\n\n  autoUpdate() {\n    console.log(\"running auto update\");\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n    this.update();\n    this.timeout = setTimeout(() => this.autoUpdate(), 60 * 60 * 1000);\n  }\n\n  messageHandler(event) {\n    switch (event.data.type) {\n      case \"pong\":\n        console.log(\"pong\");\n        break;\n      default:\n        console.log(\"unknown message\");\n    }\n  }\n\n  controller(): ServiceWorker | null {\n    return navigator.serviceWorker.controller;\n  }\n\n  checkForUpdate(): void {\n    this.controller()?.postMessage({ type: \"checkForUpdate\" });\n  }\n\n  update() {\n    this.controller()?.postMessage({ type: \"update\" });\n  }\n\n  swName(type: SwType | null | undefined = null) {\n    return `/service-worker.js?type=${type ?? SwType.PreferOnline}`;\n  }\n\n  registerMessageHandler() {\n    navigator.serviceWorker.addEventListener(\"message\", (e) =>\n      this.messageHandler(e)\n    );\n  }\n\n  async enableServiceWorker(type: SwType) {\n    if (\"serviceWorker\" in navigator && !this.registered) {\n      await navigator.serviceWorker.register(this.swName(type), {\n        scope: \"/\",\n      });\n      this.registered = true;\n    }\n    this.registerMessageHandler();\n  }\n\n  cleanDb() {\n    offlineDb.delete();\n  }\n\n  async disableServiceWorker() {\n    if (\"serviceWorker\" in navigator) {\n      const registration = await navigator.serviceWorker.getRegistration();\n      await registration?.unregister();\n      this.registered = false;\n    }\n  }\n\n  toggleKeepAlive(keepAlive: boolean) {\n    if (this.keepAlive && !keepAlive) {\n      console.log(\"[worker] keepalive -> enabling\");\n      clearInterval(this.keepAlive);\n      this.keepAlive = null;\n    } else if (keepAlive && !this.keepAlive) {\n      console.log(\"[worker] keepalive -> disabling\");\n      this.keepAlive = setInterval(\n        () => this.controller()?.postMessage({ type: \"keepalive\" }),\n        10000\n      );\n    }\n  }\n\n  async status() {\n    return await getContentStatus();\n  }\n\n  offlineSettings(): OfflineSettingsData {\n    return OfflineSettingsData.read();\n  }\n\n  async setOfflineSettings(\n    settingsData: Partial<OfflineSettingsData>\n  ): Promise<OfflineSettingsData> {\n    const current = this.offlineSettings();\n\n    if (!current.offline && settingsData.offline) {\n      await this.disableServiceWorker();\n      await this.enableServiceWorker(\n        settingsData.preferOnline || current.preferOnline\n          ? SwType.PreferOnline\n          : SwType.PreferOffline\n      );\n    } else if (\n      \"preferOnline\" in settingsData &&\n      current.preferOnline !== settingsData.preferOnline\n    ) {\n      await this.disableServiceWorker();\n      await this.enableServiceWorker(\n        settingsData.preferOnline ? SwType.PreferOnline : SwType.PreferOffline\n      );\n    }\n    if (current.offline && settingsData.offline === false) {\n      await this.disableServiceWorker();\n    }\n\n    if (settingsData.autoUpdates === false && this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    } else if (\n      settingsData.autoUpdates === true &&\n      current.autoUpdates === false\n    ) {\n      this.autoUpdate();\n    }\n\n    this.settings = new OfflineSettingsData({ ...current, ...settingsData });\n    this.settings.write();\n    return this.settings;\n  }\n\n  async clearOfflineSettings() {\n    await this.setOfflineSettings(new OfflineSettingsData());\n  }\n\n  async clear() {\n    this.controller()?.postMessage({ type: \"clear\" });\n  }\n}\n\ndeclare global {\n  interface Window {\n    mdnWorker: MDNWorker;\n  }\n}\n\nexport function getMDNWorker(): MDNWorker {\n  if (!window.mdnWorker) {\n    window.mdnWorker = new MDNWorker();\n  }\n  return window.mdnWorker;\n}\n"],"names":["SwType","ContentStatusPhase","MDNOfflineDB","Dexie","constructor","super","this","version","stores","whoami","collections","watched","notifications","contentStatusHistory","offlineDb","async","getContentStatus","toCollection","last","phase","INITIAL","local","remote","progress","timestamp","Date","MDNWorker","settings","offlineSettings","registered","timeout","keepAlive","autoUpdates","autoUpdate","offline","enableServiceWorker","preferOnline","PreferOnline","PreferOffline","disableServiceWorker","console","log","clearTimeout","update","setTimeout","messageHandler","event","data","type","controller","navigator","serviceWorker","checkForUpdate","_this$controller","postMessage","_this$controller2","swName","arguments","length","undefined","concat","registerMessageHandler","addEventListener","e","register","scope","cleanDb","delete","registration","getRegistration","unregister","toggleKeepAlive","clearInterval","setInterval","_this$controller3","OfflineSettingsData","read","settingsData","current","write","setOfflineSettings","_this$controller4","getMDNWorker","window","mdnWorker"],"sourceRoot":""}