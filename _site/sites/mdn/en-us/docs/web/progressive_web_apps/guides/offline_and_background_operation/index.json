{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Offline and background operation","mdn_url":"/en-US/docs/Web/Progressive_web_apps/Guides/Offline_and_background_operation","locale":"en-US","native":"English (US)","sidebarHTML":"<ol><li><a href=\"/en-US/docs/Web/Progressive_web_apps\"><strong>Progressive web apps</strong></a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides\"><strong>Guides</strong></a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides/What_is_a_progressive_web_app\">What is a progressive web app?</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides/Installing\">Installing and uninstalling web apps</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides/Making_PWAs_installable\">Making PWAs installable</a></li><li><em><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides/Offline_and_background_operation\" aria-current=\"page\">Offline and background operation</a></em></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides/Caching\">Caching</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Guides/Best_practices\">Best practices for PWAs</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials\"><strong>Tutorials</strong></a></li><li><ol><li><details><summary>CycleTracker</summary><ol><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/CycleTracker\">CycleTracker</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/CycleTracker/HTML_and_CSS\">Base HTML and CSS</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/CycleTracker/Secure_connection\">Secure connection</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/CycleTracker/JavaScript_functionality\">JavaScript functionality</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/CycleTracker/Manifest_file\">Manifest and iconography</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/CycleTracker/Service_workers\">Service workers</a></li></ol></details></li></ol></li><li><ol><li><details><summary>js13kGames</summary><ol><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames\">js13kGames</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/App_structure\">Progressive web app structure</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Offline_Service_workers\">Making PWAs work offline with Service workers</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Installable_PWAs\">How to make PWAs installable</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Re-engageable_Notifications_Push\">How to make PWAs re-engageable using Notifications and Push</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Loading\">Progressive loading</a></li></ol></details></li></ol></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to\"><strong>How to</strong></a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Trigger_install_prompt\">Trigger installation from your PWA</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Define_app_icons\">Define your app icons</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Create_a_standalone_app\">Create a standalone app</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Customize_your_app_colors\">Customize your app's theme and background colors</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Display_badge_on_app_icon\">Display a badge on the app icon</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Expose_common_actions_as_shortcuts\">Expose common app actions as shortcuts</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Share_data_between_apps\">Share data between apps</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/How_to/Associate_files_with_your_PWA\">Associate files with your PWA</a></li><li><a href=\"/en-US/docs/Web/Progressive_web_apps/Reference\"><strong>Reference</strong></a></li></ol>","sidebarMacro":"PWASidebar","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Usually, websites are very dependent on both reliable network connectivity and on the user having their pages open in a browser. Without network connectivity, most websites are just unusable, and if the user does not have the site open in a browser tab, most websites are unable to do anything.</p>\n<p>However, consider the following scenarios:</p>\n<ul>\n  <li>A music app enables the user to stream music while online, but can download tracks in the background and then continue to play while the user is offline.</li>\n  <li>The user composes a long email, presses \"Send\", and then loses network connectivity. The device sends the email in the background, as soon as the network is available again.</li>\n  <li>The user's chat app receives a message from one of their contacts, and although the app is not open, it displays a badge on the app icon to let the user know they have a new message.</li>\n</ul>\n<p>These are the kinds of features that users expect from installed apps. In this guide, we'll introduce a set of technologies that enable a PWA to:</p>\n<ul>\n  <li>Provide a good user experience even when the device has intermittent network connectivity</li>\n  <li>Update its state when the app is not running</li>\n  <li>Notify the user about important events that have happened while the app was not running</li>\n</ul>\n<p>The technologies introduced in this guide are:</p>\n<ul>\n  <li><a href=\"/en-US/docs/Web/API/Service_Worker_API\">Service Worker API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Background_Synchronization_API\">Background Synchronization API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Background_Fetch_API\">Background Fetch API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API\">Periodic Background Synchronization API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Push_API\">Push API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Notifications_API\">Notifications API</a></li>\n</ul>"}},{"type":"prose","value":{"id":"websites_and_workers","title":"Websites and workers","isH3":false,"content":"<p>The foundation of all the technologies we'll discuss in this guide is the <em>service worker</em>. In this section we'll provide a little background about workers and how they change the architecture of a web app.</p>\n<p>Normally, an entire website runs in a single thread. This includes the website's own JavaScript, and all the work to render the website's UI. One consequence of this is that if your JavaScript runs some long-running operation, the website's main UI is blocked, and the website appears unresponsive to the user.</p>\n<p>A <a href=\"/en-US/docs/Web/API/Service_Worker_API\">service worker</a> is a specific type of <a href=\"/en-US/docs/Web/API/Web_Workers_API\">web worker</a> that's used to implement PWAs. Like all web workers, a service worker runs in a separate thread to the main JavaScript code. The main code creates the worker, passing in a URL to the worker's script. The worker and the main code can't directly access each other's state, but can communicate by sending each other messages. Workers can be used to run computationally expensive tasks in the background: because they run in a separate thread, the main JavaScript code in the app, that implements the app's UI, can stay responsive to the user.</p>\n<p>So a PWA always has a high level architecture split between:</p>\n<ul>\n  <li>The <em>main app</em>, with the HTML, CSS, and the part of the JavaScript that implements the app's UI (by handling user events, for example)</li>\n  <li>The <em>service worker</em>, which handles offline and background tasks</li>\n</ul>\n<p>In this guide, when we show code samples, we'll indicate which part of the app the code belongs in with a comment like <code>// main.js</code> or <code>// service-worker.js</code>.</p>"}},{"type":"prose","value":{"id":"offline_operation","title":"Offline operation","isH3":false,"content":"<p>Offline operation allows a PWA to provide a good user experience even when the device does not have network connectivity. This is enabled by adding a service worker to an app.</p>\n<p>A service worker <em>controls</em> some or all of the app's pages. When the service worker is installed, it can fetch the resources from the server for the pages it controls (including pages, styles, scripts, and images, for example) and add them to a local cache. The <a href=\"/en-US/docs/Web/API/Cache\"><code>Cache</code></a> interface is used to add resources to the cache. <code>Cache</code> instances are accessible through the <a href=\"/en-US/docs/Web/API/caches\"><code>caches</code></a> property in the service worker global scope.</p>\n<p>Then whenever the app requests a resource (for example, because the user opened the app or clicked an internal link), the browser fires an event called <a href=\"/en-US/docs/Web/API/ServiceWorkerGlobalScope/fetch_event\" title=\"fetch\"><code>fetch</code></a> in the service worker's global scope. By listening for this event, the service worker can intercept the request.</p>\n<p>The event handler for the <code>fetch</code> event is passed a <a href=\"/en-US/docs/Web/API/FetchEvent\"><code>FetchEvent</code></a> object, which:</p>\n<ul>\n  <li>Provides access to the request as a <a href=\"/en-US/docs/Web/API/Request\"><code>Request</code></a> instance</li>\n  <li>Provides a <a href=\"/en-US/docs/Web/API/FetchEvent/respondWith\" title=\"respondWith()\"><code>respondWith()</code></a> method to send a response to the request.</li>\n</ul>\n<p>One way a service worker can handle requests is a \"cache-first\" strategy. In this strategy:</p>\n<ol>\n  <li>If the requested resource exists in the cache, get the resource from the cache and return the resource to the app.</li>\n  <li>If the requested resource does not exist in the cache, try to fetch the resource from the network.\n    <ol>\n      <li>If the resource could be fetched, add the resource to the cache for next time, and return the resource to the app.</li>\n      <li>If the resource could not be fetched, return some default fallback resource.</li>\n    </ol>\n  </li>\n</ol>\n<p>The following code sample shows an implementation of this:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// service-worker.js</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">putInCache</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">request<span class=\"token punctuation\">,</span> response</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> cache <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"v1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">await</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">cacheFirst</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> request<span class=\"token punctuation\">,</span> fallbackUrl <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// First try to get the resource from the cache.</span>\n  <span class=\"token keyword\">const</span> responseFromCache <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>responseFromCache<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> responseFromCache<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// If the response was not found in the cache,</span>\n  <span class=\"token comment\">// try to get the resource from the network.</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> responseFromNetwork <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// If the network request succeeded, clone the response:</span>\n    <span class=\"token comment\">// - put one copy in the cache, for the next time</span>\n    <span class=\"token comment\">// - return the original to the app</span>\n    <span class=\"token comment\">// Cloning is needed because a response can only be consumed once.</span>\n    <span class=\"token function\">putInCache</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> responseFromNetwork<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> responseFromNetwork<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// If the network request failed,</span>\n    <span class=\"token comment\">// get the fallback response from the cache.</span>\n    <span class=\"token keyword\">const</span> fallbackResponse <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>fallbackUrl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fallbackResponse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> fallbackResponse<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// When even the fallback response is not available,</span>\n    <span class=\"token comment\">// there is nothing we can do, but we must always</span>\n    <span class=\"token comment\">// return a Response object.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Network error happened\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">408</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">headers</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token string-property property\">\"Content-Type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"text/plain\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fetch\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span>\n    <span class=\"token function\">cacheFirst</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">request</span><span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">fallbackUrl</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/fallback.html\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>This means that in many situations, the web app will function well even if network connectivity is intermittent. From the point of view of the main app code, it is completely transparent: the app just makes network requests and gets responses. Also, because the service worker is in a separate thread, the main app code can stay responsive to user input while resources are fetched and cached.</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> The strategy described here is just one way a service worker could implement caching. Specifically, in a cache first strategy, we check the cache first before the network, meaning that we are more likely to return a quick response without incurring a network cost, but are more likely to return a stale response.</p>\n  <p>An alternative would be a <em>network first</em> strategy, in which we try to fetch the resource from the server first, and fall back to the cache if the device is offline.</p>\n  <p>The optimal caching strategy is dependent on the particular web app and how it is used.</p>\n</div>\n<p>For much more detail about setting up service workers and using them to add offline functionality, see our <a href=\"/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers\">guide to using service workers</a>.</p>"}},{"type":"prose","value":{"id":"background_operation","title":"Background operation","isH3":false,"content":"<p>While offline operations are the most common use for service workers, they also enable a PWA to operate even while the main app is closed. This is possible because the service worker can run while the main app is not running.</p>\n<p>This doesn't mean service workers run all the time: browsers may stop service workers when they think it is appropriate. For example, if a service worker has been inactive for a while, it will be stopped. However, the browser will restart the service worker when an event has happened that it needs to take care of. This enables a PWA to implement background operations in the following way:</p>\n<ul>\n  <li>In the main app, register a request for the service worker to perform some operation</li>\n  <li>At the appropriate time, the service worker will be restarted if necessary, and an event will fire in the service worker's scope</li>\n  <li>The service worker will perform the operation</li>\n</ul>\n<p>In the next sections, we'll discuss a few different features that use this pattern to enable a PWA to work while the main app isn't open.</p>"}},{"type":"prose","value":{"id":"background_sync","title":"Background sync","isH3":false,"content":"<p>Suppose a user composes an email and presses \"Send\". In a traditional website, they must keep the tab open until the app has sent the email: if they close the tab, or the device loses connectivity, then the message will not be sent. Background sync, defined in the <a href=\"/en-US/docs/Web/API/Background_Synchronization_API\">Background Synchronization API</a>, is the solution to this problem for PWAs.</p>\n<p>Background sync enables the app to ask its service worker to perform a task on its behalf. As soon as the device has network connectivity, the browser will restart the service worker, if necessary, and fire an event named <a href=\"/en-US/docs/Web/API/ServiceWorkerGlobalScope/sync_event\"><code>sync</code></a> in the service worker's scope. The service worker can then attempt to execute the task. If the task can't be completed, then the browser may retry a limited number of times by firing the event again.</p>"}},{"type":"prose","value":{"id":"registering_a_sync_event","title":"Registering a sync event","isH3":true,"content":"<p>To ask the service worker to perform a task, the main app can access <a href=\"/en-US/docs/Web/API/ServiceWorkerContainer/ready\" title=\"navigator.serviceWorker.ready\"><code>navigator.serviceWorker.ready</code></a>, which resolves with a <a href=\"/en-US/docs/Web/API/ServiceWorkerRegistration\"><code>ServiceWorkerRegistration</code></a> object. The app then calls <a href=\"/en-US/docs/Web/API/SyncManager/register\" title=\"sync.register()\"><code>sync.register()</code></a> on the <code>ServiceWorkerRegistration</code> object, like this:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// main.js</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">registerSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> swRegistration <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> navigator<span class=\"token punctuation\">.</span>serviceWorker<span class=\"token punctuation\">.</span>ready<span class=\"token punctuation\">;</span>\n  swRegistration<span class=\"token punctuation\">.</span>sync<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"send-message\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>Note that the app passes a name for the task: <code>\"send-message\"</code> in this case.</p>"}},{"type":"prose","value":{"id":"handling_a_sync_event","title":"Handling a sync event","isH3":true,"content":"<p>As soon as the device has network connectivity, the <code>sync</code> event fires in the service worker scope. The service worker checks the name of the task and runs the appropriate function, <code>sendMessage()</code> in this case:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// service-worker.js</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sync\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">==</span> <span class=\"token string\">\"send-message\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span><span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Note that we pass the result of the <code>sendMessage()</code> function into the event's <a href=\"/en-US/docs/Web/API/ExtendableEvent/waitUntil\" title=\"waitUntil()\"><code>waitUntil()</code></a> method. The <code>waitUntil()</code> method takes a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> as a parameter and asks the browser not to stop the service worker until the promise has settled. This is also how the browser knows whether the operation succeeded or not: if the promise rejects, then the browser may retry by firing the <code>sync</code> event again.</p>\n<p>The <code>waitUntil()</code> method is not a guarantee that the browser will not stop the service worker: if the operation takes too long, the service worker will be stopped anyway. If this happens, then the operation is aborted, and next time a <code>sync</code> event is fired, then the handler runs again from the start - it does not resume from where it left off.</p>\n<p>How long is \"too long\" is browser-specific. For Chrome, the service worker is likely to be closed if:</p>\n<ul>\n  <li>It has been idle for 30 seconds</li>\n  <li>It has been running synchronous JavaScript for 30 seconds</li>\n  <li>The promise passed to <code>waitUntil()</code> has taken more than 5 minutes to settle</li>\n</ul>"}},{"type":"prose","value":{"id":"background_fetch","title":"Background fetch","isH3":false,"content":"<p>Background sync is useful for relatively short background operations, but as we just saw: if a service worker doesn't finish handling a sync event in a relatively short time, the browser will stop the service worker. This is an intentional measure to conserve battery life and protect the user's privacy by minimizing the time for which the user's IP address is exposed to the server while the app is in the background.</p>\n<p>This makes background sync unsuitable for longer operations - downloading a movie, for example. For this scenario, you need the <a href=\"/en-US/docs/Web/API/Background_Fetch_API\">Background Fetch API</a>. With background fetch, network requests can be performed while both the main app UI and the service worker are closed.</p>\n<p>With background fetch:</p>\n<ul>\n  <li>The request is initiated from the main app UI</li>\n  <li>Whether or not the main app is open, the browser displays a persistent UI element that notifies the user about the ongoing request, and enables them to cancel it or check its progress</li>\n  <li>When the request is completed with success or failure, or the user has asked to check the request's progress, then the browser starts the service worker (if necessary) and fires the appropriate event in the service worker's scope.</li>\n</ul>"}},{"type":"prose","value":{"id":"making_a_background_fetch_request","title":"Making a background fetch request","isH3":true,"content":"<p>A background fetch request is initiated in the main app code, by calling <a href=\"/en-US/docs/Web/API/BackgroundFetchManager/fetch\" title=\"backgroundFetch.fetch()\"><code>backgroundFetch.fetch()</code></a> on the <code>ServiceWorkerRegistration</code> object, like this:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// main.js</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">requestBackgroundFetch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">movieData</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> swRegistration <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> navigator<span class=\"token punctuation\">.</span>serviceWorker<span class=\"token punctuation\">.</span>ready<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> fetchRegistration <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> swRegistration<span class=\"token punctuation\">.</span>backgroundFetch<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"download-movie\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">\"/my-movie-part-1.webm\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/my-movie-part-2.webm\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">icons</span><span class=\"token operator\">:</span> movieIcons<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">title</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Downloading my movie\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">downloadTotal</span><span class=\"token operator\">:</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>We're passing three arguments into <code>backgroundFetch.fetch()</code>:</p>\n<ol>\n  <li>An identifier for this fetch request</li>\n  <li>An array of <a href=\"/en-US/docs/Web/API/Request\"><code>Request</code></a> objects or URLs. A single background fetch request can include multiple network requests.</li>\n  <li>An object containing data for the UI that the browser uses to show the existence and progress of the request.</li>\n</ol>\n<p>The <code>backgroundFetch.fetch()</code> call returns a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> that resolves to a <a href=\"/en-US/docs/Web/API/BackgroundFetchRegistration\"><code>BackgroundFetchRegistration</code></a> object. This enables the main app to update its own UI as the request progresses. However, if the main app is closed, the fetch will continue in the background.</p>\n<p>The browser will display a persistent UI element reminding the user that the request is ongoing, giving them the chance to find out more about the request and cancel it if they wish. The UI will include an icon and title taken from the <code>icons</code> and <code>title</code> arguments, and uses <code>downloadTotal</code> as an estimate of the total download size, to show the request's progress.</p>"}},{"type":"prose","value":{"id":"handling_request_outcomes","title":"Handling request outcomes","isH3":true,"content":"<p>When the fetch has finished with success or failure, or the user has clicked the progress UI, then the browser starts the app's service worker, if necessary, and fires an event in the service worker's scope. The following events can be fired:</p>\n<ul>\n  <li><code>backgroundfetchsuccess</code>: all requests were successful</li>\n  <li><code>backgroundfetchfail</code>: at least one request failed</li>\n  <li><code>backgroundfetchabort</code>: the fetch was canceled by the user or by the main app</li>\n  <li><code>backgroundfetchclick</code>: the user clicked on the progress UI element that the browser is showing</li>\n</ul>\n<h4 id=\"retrieving_response_data\">Retrieving response data</h4>\n<p>In the handlers for the <code>backgroundfetchsuccess</code>, <code>backgroundfetchfail</code>, and <code>backgroundfetchabort</code> events, the service worker can retrieve the request and response data.</p>\n<p>To get the response, the event handler accesses the event's <a href=\"/en-US/docs/Web/API/BackgroundFetchEvent/registration\" title=\"registration\"><code>registration</code></a> property. This is a <a href=\"/en-US/docs/Web/API/BackgroundFetchRegistration\"><code>BackgroundFetchRegistration</code></a> object, which has <a href=\"/en-US/docs/Web/API/BackgroundFetchRegistration/matchAll\" title=\"matchAll()\"><code>matchAll()</code></a> and <a href=\"/en-US/docs/Web/API/BackgroundFetchRegistration/match\" title=\"match()\"><code>match()</code></a> methods that return <a href=\"/en-US/docs/Web/API/BackgroundFetchRecord\"><code>BackgroundFetchRecord</code></a> objects matching the given URL (or, in the case of <code>matchAll()</code> all records if no URL is given).</p>\n<p>Each <code>BackgroundFetchRecord</code> has a <a href=\"/en-US/docs/Web/API/BackgroundFetchRecord/responseReady\" title=\"responseReady\"><code>responseReady</code></a> property that is a <code>Promise</code> which resolves with the <a href=\"/en-US/docs/Web/API/Response\"><code>Response</code></a>, once the response is available.</p>\n<p>So to access response data, the handler could do something like:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// service-worker.js</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"backgroundfetchsuccess\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> registration <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>registration<span class=\"token punctuation\">;</span>\n\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> registration <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>registration<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> records <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> registration<span class=\"token punctuation\">.</span><span class=\"token function\">matchAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> responsePromises <span class=\"token operator\">=</span> records<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">record</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">await</span> record<span class=\"token punctuation\">.</span>responseReady<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> responses <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>responsePromises<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// do something with the responses</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Since the response data won't be available after the handler exits, the handler should store the data (for example, in the <a href=\"/en-US/docs/Web/API/Cache\"><code>Cache</code></a>) if the app still wants it.</p>\n<h4 id=\"updating_the_browsers_ui\">Updating the browser's UI</h4>\n<p>The event object passed into <code>backgroundfetchsuccess</code> and <code>backgroundfetchfail</code> also has an <a href=\"/en-US/docs/Web/API/BackgroundFetchUpdateUIEvent/updateUI\" title=\"updateUI()\"><code>updateUI()</code></a> method, which can be used to update the UI that the browser shows to keep the user informed about the fetch operation. With <code>updateUI()</code>, the handler can update the UI element's title and icon:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// service-worker.js</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"backgroundfetchsuccess\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// retrieve and store response data</span>\n  <span class=\"token comment\">// ...</span>\n\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">updateUI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">title</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Finished your download!\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"backgroundfetchfail\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">updateUI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">title</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Could not complete download\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h4 id=\"responding_to_user_interaction\">Responding to user interaction</h4>\n<p>The <code>backgroundfetchclick</code> event is fired when the user has clicked on the UI element that the browser shows while the fetch is ongoing.</p>\n<p>The expected response here is to open a window giving the user more information about the fetch operation, which can be done from the service worker using <a href=\"/en-US/docs/Web/API/Clients/openWindow\" title=\"clients.openWindow()\"><code>clients.openWindow()</code></a>. For example:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// service-worker.js</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"backgroundfetchclick\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> registration <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>registration<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>registration<span class=\"token punctuation\">.</span>result <span class=\"token operator\">===</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    clients<span class=\"token punctuation\">.</span><span class=\"token function\">openWindow</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/play-movie\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    clients<span class=\"token punctuation\">.</span><span class=\"token function\">openWindow</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/movie-download-progress\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"periodic_background_sync","title":"Periodic background sync","isH3":false,"content":"<p>The <a href=\"/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API\">Periodic Background Synchronization API</a> enables a PWA to periodically update its data in the background, while the main app is closed.</p>\n<p>This can greatly improve the offline experience offered by a PWA. Consider an app that depends on reasonably fresh content, like a news app. If the device is offline when the user opens the app, then even with service worker-based caching the stories will only be as fresh as the last time the app was opened. With periodic background sync, the app could have refreshed its stories in the background, when the device had connectivity, and so could be able to show relatively fresh content to the user.</p>\n<p>This takes advantage of the fact that on a mobile device especially, connectivity is not poor so much as <em>intermittent</em>: by taking advantage of the times that the device has connectivity, the app can smooth over the connectivity gaps.</p>"}},{"type":"prose","value":{"id":"registering_a_periodic_sync_event","title":"Registering a periodic sync event","isH3":true,"content":"<p>The code for registering a periodic sync event follows the same pattern as that for <a href=\"#registering_a_sync_event\">registering a sync event</a>. The <a href=\"/en-US/docs/Web/API/ServiceWorkerRegistration\"><code>ServiceWorkerRegistration</code></a> has a <a href=\"/en-US/docs/Web/API/ServiceWorkerRegistration/periodicSync\" title=\"periodicSync\"><code>periodicSync</code></a> property, which has a <a href=\"/en-US/docs/Web/API/PeriodicSyncManager/register\" title=\"register()\"><code>register()</code></a> method taking the name of the periodic sync as a parameter.</p>\n<p>However, <code>periodicSync.register()</code> takes an extra argument, which is an object with a <code>minInterval</code> property. This represents the minimum interval, in milliseconds, between synchronization attempts:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// main.js</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">registerPeriodicSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> swRegistration <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> navigator<span class=\"token punctuation\">.</span>serviceWorker<span class=\"token punctuation\">.</span>ready<span class=\"token punctuation\">;</span>\n  swRegistration<span class=\"token punctuation\">.</span>periodicSync<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"update-news\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// try to update every 24 hours</span>\n    <span class=\"token literal-property property\">minInterval</span><span class=\"token operator\">:</span> <span class=\"token number\">24</span> <span class=\"token operator\">*</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"handling_a_periodic_sync_event","title":"Handling a periodic sync event","isH3":true,"content":"<p>Although the PWA asks for a particular interval in the <code>register()</code> call, it's up to the browser how often to generate periodic sync events. Apps that users open and interact with often will be more likely to receive periodic sync events, and will receive them more often, than apps which the user rarely or never interacts with.</p>\n<p>When the browser has decided to generate a periodic sync event, the pattern is the following: it starts the service worker, if necessary, and fires a <a href=\"/en-US/docs/Web/API/ServiceWorkerGlobalScope/periodicsync_event\" title=\"periodicSync\"><code>periodicSync</code></a> event in the service worker's global scope.</p>\n<p>The service worker's event handler checks the name of the event, and calls the appropriate function inside the event's <a href=\"/en-US/docs/Web/API/ExtendableEvent/waitUntil\" title=\"waitUntil()\"><code>waitUntil()</code></a> method:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// service-worker.js</span>\n\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"periodicsync\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">\"update-news\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">waitUntil</span><span class=\"token punctuation\">(</span><span class=\"token function\">updateNews</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Inside <code>updateNews()</code>, the service worker can fetch and cache the latest stories. The <code>updateNews()</code> function should complete relatively quickly: if the service worker takes too long updating its content, the browser will stop it.</p>"}},{"type":"prose","value":{"id":"unregistering_a_periodic_sync","title":"Unregistering a periodic sync","isH3":true,"content":"<p>When the PWA no longer needs periodic background updates, (for example, because the user has switched them off in the app's settings) then the PWA should ask the browser to stop generating periodic sync events, by calling the <a href=\"/en-US/docs/Web/API/PeriodicSyncManager/unregister\" title=\"unregister()\"><code>unregister()</code></a> method of <a href=\"/en-US/docs/Web/API/ServiceWorkerRegistration/periodicSync\" title=\"periodicSync\"><code>periodicSync</code></a>:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// main.js</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">registerPeriodicSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> swRegistration <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> navigator<span class=\"token punctuation\">.</span>serviceWorker<span class=\"token punctuation\">.</span>ready<span class=\"token punctuation\">;</span>\n  swRegistration<span class=\"token punctuation\">.</span>periodicSync<span class=\"token punctuation\">.</span><span class=\"token function\">unregister</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"update-news\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"push","title":"Push","isH3":false,"content":"<p>The <a href=\"/en-US/docs/Web/API/Push_API\">Push API</a> enables a PWA to receive messages pushed from the server, whether the app is running or not. When the message is received by the device, the app's service worker is started and handles the message, and a <a href=\"/en-US/docs/Web/API/Notifications_API\">notification</a> is shown to the user. The specification allows for \"silent push\" in which no notification is shown, but no browsers support this, because of privacy concerns (for example, that push could then be used to track a user's location).</p>\n<p>Displaying a notification to the user distracts them from whatever they were doing and has the potential to be very annoying, so use push messages with care. In general, they are suitable for situations in which you need to alert the user about something, and can't wait until the next time they open your app.</p>\n<p>A common use case for push notifications is chat apps: when the user receives a message from one of their contacts, it is delivered as a push message and the app shows a notification.</p>\n<p>Push messages are not sent directly from the app server to the device. Instead, your app server sends messages to a push service, from which the device can retrieve them and deliver them to the app.</p>\n<p>This also means that messages from your server to the push service need to be <a href=\"/en-US/docs/Glossary/Encryption\">encrypted</a> (so the push service can't read them) and <a href=\"/en-US/docs/Glossary/Signature/Security\">signed</a> (so the push service knows that the messages are really from your server, and not from someone impersonating your server).</p>\n<p>The push service is operated by the browser vendor or by a third party, and the app server communicates with it using the <a href=\"https://datatracker.ietf.org/doc/html/rfc8030\" class=\"external\" target=\"_blank\">HTTP Push</a> protocol. The app server can use a third-party library such as <a href=\"https://github.com/web-push-libs/web-push\" class=\"external\" target=\"_blank\">web-push</a> to take care of the protocol details.</p>"}},{"type":"prose","value":{"id":"subscribing_to_push_messages","title":"Subscribing to push messages","isH3":true,"content":"<p>The pattern for subscribing to push messages looks like this:</p>\n<p>\n  <img src=\"/en-US/docs/Web/Progressive_web_apps/Guides/Offline_and_background_operation/push-messaging-1.svg\" alt=\"Diagram showing push message subscription steps\" width=\"600\" height=\"500\" loading=\"lazy\">\n</p>\n<ol>\n  <li>As a prerequisite, the app server needs to be provisioned with a <a href=\"/en-US/docs/Glossary/Public-key_cryptography\">public/private key pair</a>, so it can sign push messages. Signing messages needs to follow the <a href=\"https://datatracker.ietf.org/doc/html/draft-thomson-webpush-vapid-02\" class=\"external\" target=\"_blank\">VAPID</a> specification.</li>\n  <li>On the device, the app uses the <a href=\"/en-US/docs/Web/API/PushManager/subscribe\"><code>PushManager.subscribe()</code></a> method to subscribe to messages from the server. The <code>subscribe()</code> method:\n    <ul>\n      <li>Takes the app server's public key as an argument: this is what the push service will use to verify the signature on messages from the app server.</li>\n      <li>Returns a <code>Promise</code> that resolves to a <a href=\"/en-US/docs/Web/API/PushSubscription\"><code>PushSubscription</code></a> object. This object includes:\n        <ul>\n          <li>The <a href=\"/en-US/docs/Web/API/PushSubscription/endpoint\">endpoint</a> for the push service: this is how the app server knows where to send push messages.</li>\n          <li>The <a href=\"/en-US/docs/Web/API/PushSubscription/getKey\">public encryption key</a> that your server will use to encrypt messages to the push service.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>The app sends the endpoint and public encryption key to your server (for example, using <a href=\"/en-US/docs/Web/API/fetch\"><code>fetch()</code></a>).</li>\n</ol>\n<p>After this, the app server is able to start sending push messages.</p>"}},{"type":"prose","value":{"id":"sending_delivering_and_handling_push_messages","title":"Sending, delivering, and handling push messages","isH3":true,"content":"<p>When an event happens on the server that the server wants the app to handle, the server can send messages, and the sequence of steps is like this:</p>\n<p>\n  <img src=\"/en-US/docs/Web/Progressive_web_apps/Guides/Offline_and_background_operation/push-messaging-2.svg\" alt=\"Diagram showing push message sending and delivery steps\" width=\"700\" height=\"600\" loading=\"lazy\">\n</p>\n<ol>\n  <li>The app server signs the message using its private signing key and encrypts the message using the public encryption key for the push service. The app server can use a library such as <a href=\"https://github.com/web-push-libs/web-push\" class=\"external\" target=\"_blank\">web-push</a> to simplify this.</li>\n  <li>The app server sends the message to the endpoint for the push service, using the <a href=\"https://datatracker.ietf.org/doc/html/rfc8030\" class=\"external\" target=\"_blank\">HTTP Push</a> protocol, and again optionally using a library, like web-push.</li>\n  <li>The push service checks the signature on the message, and if the signature is valid, the push service queues the message for delivery.</li>\n  <li>When the device has network connectivity, the push service delivers the encrypted message to the browser.</li>\n  <li>When the browser receives the encrypted message, it decrypts the message.</li>\n  <li>The browser starts the service worker if necessary, and fires an event called <a href=\"/en-US/docs/Web/API/ServiceWorkerGlobalScope/push_event\" title=\"push\"><code>push</code></a> in the service worker's global scope. The event handler is passed a <a href=\"/en-US/docs/Web/API/PushEvent\"><code>PushEvent</code></a> object, which contains the message data.</li>\n  <li>In its event handler, the service worker does any processing of the message. As usual, the event handler calls <code>event.waitUntil()</code> to ask the browser to keep the service worker running.</li>\n  <li>In its event handler, the service worker creates a notification using <a href=\"/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification\" title=\"registration.showNotification()\"><code>registration.showNotification()</code></a>.</li>\n  <li>If the user clicks the notification or closes it, the <a href=\"/en-US/docs/Web/API/ServiceWorkerGlobalScope/notificationclick_event\" title=\"notificationclick\"><code>notificationclick</code></a> and <a href=\"/en-US/docs/Web/API/ServiceWorkerGlobalScope/notificationclose_event\" title=\"notificationclose\"><code>notificationclose</code></a>, respectively, are fired in the service worker's global scope. These enable the app to handle the user's response to the notification.</li>\n</ol>"}},{"type":"prose","value":{"id":"permissions_and_restrictions","title":"Permissions and restrictions","isH3":false,"content":"<p>Browsers have to find a balance in which they can provide powerful APIs to web developers while protecting users from malicious, exploitative, or poorly-written websites. One of the main protections they offer is that users can close the website's pages, and it's then not active on their device any more. The APIs described in this article tend to violate that assurance, so browsers have to take extra steps to help ensure that users are aware of this, and that the APIs are used in ways that align with the interests of users.</p>\n<p>In this section we'll outline these steps. Several of these APIs require explicit <a href=\"/en-US/docs/Web/API/Permissions_API\">user permission</a>, and various other restrictions and design choices to help protect users.</p>\n<ul>\n  <li>The Background Sync API does not need an explicit user permission, but issuing a background sync request may only be made while the main app is open, and browsers limit the number of retries and the length of time background sync operations can take.</li>\n  <li>The Background Fetch API requires the <code>\"background-fetch\"</code> user permission, and the browser displays the ongoing progress of the fetch operation, enabling the user to cancel it.</li>\n  <li>The Periodic Background Sync API requires the <code>\"periodic-background-sync\"</code> user permission, and browsers should allow users to disable periodic background sync completely. Also, browsers may tie the frequency of sync events to the extent to which the user chooses to interact with the app: so an app that the user rarely uses may receive few events (or even no events at all).</li>\n  <li>The Push API requires the <code>\"push\"</code> user permission, and all browsers require push events to be user visible, meaning that they generate a user-visible notification.</li>\n</ul>"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":""}},{"type":"prose","value":{"id":"reference","title":"Reference","isH3":true,"content":"<ul>\n  <li><a href=\"/en-US/docs/Web/API/Service_Worker_API\">Service Worker API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Background_Synchronization_API\">Background Synchronization API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Background_Fetch_API\">Background Fetch API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API\">Periodic Background Synchronization API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Push_API\">Push API</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Notifications_API\">Notifications API</a></li>\n</ul>"}},{"type":"prose","value":{"id":"guides","title":"Guides","isH3":true,"content":"<ul>\n  <li><a href=\"https://developer.chrome.com/blog/background-sync/\" class=\"external\" target=\"_blank\">Introducing Background Sync</a> on web.dev (2017)</li>\n  <li><a href=\"https://developer.chrome.com/blog/background-fetch/\" class=\"external\" target=\"_blank\">Introducing Background Fetch</a> on web.dev (2022)</li>\n  <li><a href=\"https://developer.chrome.com/articles/periodic-background-sync/\" class=\"external\" target=\"_blank\">The Periodic Background Sync API</a> on web.dev (2020)</li>\n  <li><a href=\"https://web.dev/explore/notifications\" class=\"external\" target=\"_blank\">Notifications</a> on web.dev</li>\n  <li><a href=\"https://web.dev/articles/pwa-with-offline-streaming\" class=\"external\" target=\"_blank\">PWA with offline streaming</a> on web.dev (2021)</li>\n</ul>"}}],"toc":[{"text":"Websites and workers","id":"websites_and_workers"},{"text":"Offline operation","id":"offline_operation"},{"text":"Background operation","id":"background_operation"},{"text":"Background sync","id":"background_sync"},{"text":"Background fetch","id":"background_fetch"},{"text":"Periodic background sync","id":"periodic_background_sync"},{"text":"Push","id":"push"},{"text":"Permissions and restrictions","id":"permissions_and_restrictions"},{"text":"See also","id":"see_also"}],"summary":"Usually, websites are very dependent on both reliable network connectivity and on the user having their pages open in a browser. Without network connectivity, most websites are just unusable, and if the user does not have the site open in a browser tab, most websites are unable to do anything.","popularity":0.0121,"modified":"2023-10-25T17:27:32.000Z","source":{"folder":"en-us/web/progressive_web_apps/guides/offline_and_background_operation","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/progressive_web_apps/guides/offline_and_background_operation/index.md","last_commit_url":"https://github.com/mdn/content/commit/835d6632d59993861a0458510402787f8a2c3cb3","filename":"index.md"},"short_title":"Offline and background operation","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/Progressive_web_apps","title":"Progressive web apps"},{"uri":"/en-US/docs/Web/Progressive_web_apps/Guides","title":"Guides"},{"uri":"/en-US/docs/Web/Progressive_web_apps/Guides/Offline_and_background_operation","title":"Offline and background operation"}],"pageTitle":"Offline and background operation - Progressive web apps | MDN","noIndexing":false}}