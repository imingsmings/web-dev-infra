{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Using WebRTC data channels","mdn_url":"/en-US/docs/Web/API/WebRTC_API/Using_data_channels","locale":"en-US","native":"English (US)","sidebarHTML":"<ol><li><strong><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC API</a></strong></li><li class=\"toggle\"><details open=\"\"><summary>Guides</summary><ol><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Protocols\">Introduction to WebRTC protocols</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Connectivity\">WebRTC connectivity</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Perfect_negotiation\">Establishing a connection: The WebRTC perfect negotiation pattern</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC session</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling\">Signaling and video calling</a></li><li><em><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_data_channels\" aria-current=\"page\">Using WebRTC data channels</a></em></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_DTMF\">Using DTMF with WebRTC</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms\">Using WebRTC Encoded Transforms</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API#interoperability\">WebRTC API</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">A simple RTCDataChannel sample</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an Internet-Connected Phone with PeerJS</a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Interfaces</summary><ol><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceErrorEvent\"><code>RTCPeerConnectionIceErrorEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCCertificate\"><code>RTCCertificate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpSender\"><code>RTCRtpSender</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpReceiver\"><code>RTCRtpReceiver</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpTransceiver\"><code>RTCRtpTransceiver</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport\"><code>RTCDtlsTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport\"><code>RTCIceTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCTrackEvent\"><code>RTCTrackEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSctpTransport\"><code>RTCSctpTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannelEvent\"><code>RTCDataChannelEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFSender\"><code>RTCDTMFSender</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFToneChangeEvent\"><code>RTCDTMFToneChangeEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCErrorEvent\"><code>RTCErrorEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpScriptTransform\"><code>RTCRtpScriptTransform</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpScriptTransformer\"><code>RTCRtpScriptTransformer</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCEncodedVideoFrame\"><code>RTCEncodedVideoFrame</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCEncodedAudioFrame\"><code>RTCEncodedAudioFrame</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCTransformEvent\"><code>RTCTransformEvent</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Properties</summary><ol><li><a href=\"/en-US/docs/Web/API/Navigator/mediaDevices\"><code>Navigator.mediaDevices</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpReceiver/transform\"><code>RTCRtpReceiver.transform</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpSender/transform\"><code>RTCRtpSender.transform</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Methods</summary><ol><li><a href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Events</summary><ol><li><a href=\"/en-US/docs/Web/API/DedicatedWorkerGlobalScope/rtctransform_event\"><code>DedicatedWorkerGlobalScope</code>: <code>rtctransform</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFSender/tonechange_event\"><code>RTCDTMFSender</code>: <code>tonechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/bufferedamountlow_event\"><code>RTCDataChannel</code>: <code>bufferedamountlow</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/close_event\"><code>RTCDataChannel</code>: <code>close</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/closing_event\"><code>RTCDataChannel</code>: <code>closing</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/error_event\"><code>RTCDataChannel</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/message_event\"><code>RTCDataChannel</code>: <code>message</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/open_event\"><code>RTCDataChannel</code>: <code>open</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport/error_event\"><code>RTCDtlsTransport</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport/statechange_event\"><code>RTCDtlsTransport</code>: <code>statechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/error_event\"><code>RTCIceTransport</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/gatheringstatechange_event\"><code>RTCIceTransport</code>: <code>gatheringstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/selectedcandidatepairchange_event\"><code>RTCIceTransport</code>: <code>selectedcandidatepairchange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/statechange_event\"><code>RTCIceTransport</code>: <code>statechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/connectionstatechange_event\"><code>RTCPeerConnection</code>: <code>connectionstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/datachannel_event\"><code>RTCPeerConnection</code>: <code>datachannel</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\"><code>RTCPeerConnection</code>: <code>icecandidate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidateerror_event\"><code>RTCPeerConnection</code>: <code>icecandidateerror</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/iceconnectionstatechange_event\"><code>RTCPeerConnection</code>: <code>iceconnectionstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\"><code>RTCPeerConnection</code>: <code>icegatheringstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/negotiationneeded_event\"><code>RTCPeerConnection</code>: <code>negotiationneeded</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingstatechange_event\"><code>RTCPeerConnection</code>: <code>signalingstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/track_event\"><code>RTCPeerConnection</code>: <code>track</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSctpTransport/error_event\"><code>RTCSctpTransport</code>: <code>error</code></a></li></ol></details></li></ol>","sidebarMacro":"DefaultAPISidebar","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>In this guide, we'll examine how to add a data channel to a peer connection, which can then be used to securely exchange arbitrary data; that is, any kind of data we wish, in any format we choose.</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> Since all WebRTC components are required to use encryption, any data transmitted on an <code>RTCDataChannel</code> is automatically secured using Datagram Transport Layer Security (<strong>DTLS</strong>). See <a href=\"#security\">Security</a> below for more information.</p>\n</div>"}},{"type":"prose","value":{"id":"creating_a_data_channel","title":"Creating a data channel","isH3":false,"content":"<p>The underlying data transport used by the <a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a> can be created in one of two ways:</p>\n<ul>\n  <li>Let WebRTC create the transport and announce it to the remote peer for you (by causing it to receive a <a href=\"/en-US/docs/Web/API/RTCPeerConnection/datachannel_event\" title=\"datachannel\"><code>datachannel</code></a> event). This is the easy way, and works for a wide variety of use cases, but may not be flexible enough for your needs.</li>\n  <li>Write your own code to negotiate the data transport and write your own code to signal to the other peer that it needs to connect to the new channel.</li>\n</ul>\n<p>Let's look at each of these cases, starting with the first, which is the most common.</p>"}},{"type":"prose","value":{"id":"automatic_negotiation","title":"Automatic negotiation","isH3":true,"content":"<p>Often, you can allow the peer connection to handle negotiating the <a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a> connection for you. To do this, call</p>\n<p><a href=\"/en-US/docs/Web/API/RTCPeerConnection/createDataChannel\" title=\"createDataChannel()\"><code>createDataChannel()</code></a> without specifying a value for the <code>negotiated</code> property, or specifying the property with a value of <code>false</code>. This will automatically trigger the <code>RTCPeerConnection</code> to handle the negotiations for you, causing the remote peer to create a data channel and linking the two together across the network.</p>\n<p>The <code>RTCDataChannel</code> object is returned immediately by <code>createDataChannel()</code>; you can tell when the connection has been made successfully by watching for the <a href=\"/en-US/docs/Web/API/RTCDataChannel/open_event\" title=\"open\"><code>open</code></a> event to be sent to the <code>RTCDataChannel</code>.</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> dataChannel <span class=\"token operator\">=</span> pc<span class=\"token punctuation\">.</span><span class=\"token function\">createDataChannel</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyApp Channel\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndataChannel<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"open\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginTransmission</span><span class=\"token punctuation\">(</span>dataChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"manual_negotiation","title":"Manual negotiation","isH3":true,"content":"<p>To manually negotiate the data channel connection, you need to first create a new <a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a> object using the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/createDataChannel\" title=\"createDataChannel()\"><code>createDataChannel()</code></a> method on the <a href=\"/en-US/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, specifying in the options a <code>negotiated</code> property set to <code>true</code>. This signals to the peer connection to not attempt to negotiate the channel on your behalf.</p>\n<p>Then negotiate the connection out-of-band, using a web server or other means. This process should signal to the remote peer that it should create its own <code>RTCDataChannel</code> with the <code>negotiated</code> property also set to <code>true</code>, using the same <a href=\"/en-US/docs/Web/API/RTCDataChannel/id\" title=\"id\"><code>id</code></a>. This will link the two objects across the <code>RTCPeerConnection</code>.</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> dataChannel <span class=\"token operator\">=</span> pc<span class=\"token punctuation\">.</span><span class=\"token function\">createDataChannel</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyApp Channel\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">negotiated</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndataChannel<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"open\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginTransmission</span><span class=\"token punctuation\">(</span>dataChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">requestRemoteChannel</span><span class=\"token punctuation\">(</span>dataChannel<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>In this code snippet, the channel is created with <code>negotiated</code> set to <code>true</code>, then a function called <code>requestRemoteChannel()</code> is used to trigger negotiation, to create a remote channel with the same ID as the local channel.</p>\n<p>Doing this lets you create data channels with each peer using different properties, and to create channels declaratively by using the same value for <code>id</code>.</p>"}},{"type":"prose","value":{"id":"buffering","title":"Buffering","isH3":false,"content":"<p>WebRTC data channels support buffering of outbound data. This is handled automatically. While there's no way to control the size of the buffer, you can learn how much data is currently buffered, and you can choose to be notified by an event when the buffer starts to run low on queued data. This makes it easy to write efficient routines that make sure there's always data ready to send without over-using memory or swamping the channel completely.</p>"}},{"type":"prose","value":{"id":"understanding_message_size_limits","title":"Understanding message size limits","isH3":false,"content":"<p>For any data being transmitted over a network, there are size restrictions. At a fundamental level, the individual network packets can't be larger than a certain value (the exact number depends on the network and the transport layer being used). At the application level—that is, within the <a href=\"/en-US/docs/Glossary/User_agent\">user agent's</a> implementation of WebRTC on which your code is running—the WebRTC implementation implements features to support messages that are larger than the maximum packet size on the network's transport layer.</p>\n<p>This can complicate things, since you don't necessarily know what the size limits are for various user agents, and how they respond when a larger message is sent or received. Even when user agents share the same underlying library for handling Stream Control Transmission Protocol (SCTP) data, there can still be variations due to how the library is used. For example, both Firefox and Google Chrome use the <a href=\"https://github.com/sctplab/usrsctp\" class=\"external\" target=\"_blank\"><code>usrsctp</code></a> library to implement SCTP, but there are still situations in which data transfer on an <code>RTCDataChannel</code> can fail due to differences in how they call the library and react to errors it returns.</p>\n<p>When two users running Firefox are communicating on a data channel, the message size limit is much larger than when Firefox and Chrome are communicating because Firefox implements a now deprecated technique for sending large messages in multiple SCTP messages, which Chrome does not. Chrome will instead see a series of messages that it believes are complete, and will deliver them to the receiving <code>RTCDataChannel</code> as multiple messages.</p>\n<p>Messages smaller than 16 KiB can be sent without concern, as all major user agents handle them the same way. Beyond that, things get more complicated.</p>"}},{"type":"prose","value":{"id":"concerns_with_large_messages","title":"Concerns with large messages","isH3":true,"content":"<p>Currently, it's not practical to use <code>RTCDataChannel</code> for messages larger than 64 KiB (16 KiB if you want to support cross-browser exchange of data). The problem arises from the fact that SCTP—the protocol used for sending and receiving data on an <code>RTCDataChannel</code>—was originally designed for use as a signaling protocol. It was expected that messages would be relatively small. Support for messages larger than the network layer's <a href=\"https://en.wikipedia.org/wiki/Maximum_transmission_unit\" class=\"external\" target=\"_blank\">MTU</a> was added almost as an afterthought, in case signaling messages needed to be larger than the MTU. This feature requires that each piece of the message have consecutive sequence numbers, so they have to be transmitted one after another, without any other data interleaved between them.</p>\n<p>This eventually became a problem. Over time, various applications (including those implementing WebRTC) began to use SCTP to transmit larger and larger messages. Eventually it was realized that when the messages become too large, it's possible for the transmission of a large message to block all other data transfers on that data channel—including critical signaling messages.</p>\n<p>This will become an issue when browsers properly support the current standard for supporting larger messages—the end-of-record (EOR) flag that indicates when a message is the last one in a series that should be treated as a single payload. This is implemented in Firefox 57, but is not yet implemented in Chrome (see <a href=\"https://bugs.chromium.org/p/webrtc/issues/detail?id=7774\" class=\"external\" target=\"_blank\">Chromium Bug 7774</a>). With EOR support in place, <code>RTCDataChannel</code> payloads can be much larger (officially up to 256 KiB, but Firefox's implementation caps them at a whopping 1 GiB). Even at 256 KiB, that's large enough to cause noticeable delays in handling urgent traffic. If you go even larger, the delays can become untenable unless you are certain of your operational conditions.</p>\n<p>In order to resolve this issue, a new system of <strong>stream schedulers</strong> (usually referred to as the \"SCTP ndata specification\") has been designed to make it possible to interleave messages sent on different streams, including streams used to implement WebRTC data channels. This <a href=\"https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-sctp-ndata\" class=\"external\" target=\"_blank\">proposal</a> is still in IETF draft form, but once implemented, it will make it possible to send messages with essentially no size limitations, since the SCTP layer will automatically interleave the underlying sub-messages to ensure that every channel's data has the opportunity to get through.</p>\n<p>Firefox support for ndata is in the process of being implemented; see <a href=\"https://bugzil.la/1381145\" class=\"external\" target=\"_blank\">Firefox bug 1381145</a> to track it becoming available for general use. The Chrome team is tracking their implementation of ndata support in <a href=\"https://bugs.chromium.org/p/webrtc/issues/detail?id=5696\" class=\"external\" target=\"_blank\">Chrome Bug 5696</a>.</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> Much of the information in this section is based in part on the blog post <a href=\"https://lgrahl.de/articles/demystifying-webrtc-dc-size-limit.html\" class=\"external\" target=\"_blank\">Demystifying WebRTC's Data Channel Message Size Limitations</a>, written by Lennart Grahl. He goes into a bit more detail there, but as browsers have been updated since then some of it may be out-of-date. In addition, as time goes by, it will become more so, especially once EOR and ndata support are fully integrated in the major browsers.</p>\n</div>"}},{"type":"prose","value":{"id":"security","title":"Security","isH3":false,"content":"<p>All data transferred using WebRTC is encrypted. In the case of <code>RTCDataChannel</code>, the encryption used is Datagram Transport Layer Security (DTLS), which is based on <a href=\"/en-US/docs/Web/Security/Transport_Layer_Security\">Transport Layer Security</a> (TLS). Since TLS is used to secure every HTTPS connection, any data you send on a data channel is as secure as any other data sent or received by the user's browser.</p>\n<p>More fundamentally, since WebRTC is a peer-to-peer connection between two user agents, the data never passes through the web or application server. This reduces opportunities to have the data intercepted.</p>"}}],"toc":[{"text":"Creating a data channel","id":"creating_a_data_channel"},{"text":"Buffering","id":"buffering"},{"text":"Understanding message size limits","id":"understanding_message_size_limits"},{"text":"Security","id":"security"}],"summary":"In this guide, we'll examine how to add a data channel to a peer connection, which can then be used to securely exchange arbitrary data; that is, any kind of data we wish, in any format we choose.","popularity":0.0056,"modified":"2023-04-25T06:06:24.000Z","source":{"folder":"en-us/web/api/webrtc_api/using_data_channels","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/api/webrtc_api/using_data_channels/index.md","last_commit_url":"https://github.com/mdn/content/commit/bf7a7b9c81c465afc78519681bf0043ad3587689","filename":"index.md"},"short_title":"Using WebRTC data channels","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/en-US/docs/Web/API/WebRTC_API/Using_data_channels","title":"Using WebRTC data channels"}],"pageTitle":"Using WebRTC data channels - Web APIs | MDN","noIndexing":false}}