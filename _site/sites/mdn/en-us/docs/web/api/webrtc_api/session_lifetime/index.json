{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Lifetime of a WebRTC session","mdn_url":"/en-US/docs/Web/API/WebRTC_API/Session_lifetime","locale":"en-US","native":"English (US)","sidebarHTML":"<ol><li><strong><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC API</a></strong></li><li class=\"toggle\"><details open=\"\"><summary>Guides</summary><ol><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Protocols\">Introduction to WebRTC protocols</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Connectivity\">WebRTC connectivity</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Perfect_negotiation\">Establishing a connection: The WebRTC perfect negotiation pattern</a></li><li><em><a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime\" aria-current=\"page\">Lifetime of a WebRTC session</a></em></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling\">Signaling and video calling</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_data_channels\">Using WebRTC data channels</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_DTMF\">Using DTMF with WebRTC</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms\">Using WebRTC Encoded Transforms</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API#interoperability\">WebRTC API</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">A simple RTCDataChannel sample</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an Internet-Connected Phone with PeerJS</a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Interfaces</summary><ol><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceErrorEvent\"><code>RTCPeerConnectionIceErrorEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCCertificate\"><code>RTCCertificate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpSender\"><code>RTCRtpSender</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpReceiver\"><code>RTCRtpReceiver</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpTransceiver\"><code>RTCRtpTransceiver</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport\"><code>RTCDtlsTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport\"><code>RTCIceTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCTrackEvent\"><code>RTCTrackEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSctpTransport\"><code>RTCSctpTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannelEvent\"><code>RTCDataChannelEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFSender\"><code>RTCDTMFSender</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFToneChangeEvent\"><code>RTCDTMFToneChangeEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCErrorEvent\"><code>RTCErrorEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpScriptTransform\"><code>RTCRtpScriptTransform</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpScriptTransformer\"><code>RTCRtpScriptTransformer</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCEncodedVideoFrame\"><code>RTCEncodedVideoFrame</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCEncodedAudioFrame\"><code>RTCEncodedAudioFrame</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCTransformEvent\"><code>RTCTransformEvent</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Properties</summary><ol><li><a href=\"/en-US/docs/Web/API/Navigator/mediaDevices\"><code>Navigator.mediaDevices</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpReceiver/transform\"><code>RTCRtpReceiver.transform</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpSender/transform\"><code>RTCRtpSender.transform</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Methods</summary><ol><li><a href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Events</summary><ol><li><a href=\"/en-US/docs/Web/API/DedicatedWorkerGlobalScope/rtctransform_event\"><code>DedicatedWorkerGlobalScope</code>: <code>rtctransform</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFSender/tonechange_event\"><code>RTCDTMFSender</code>: <code>tonechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/bufferedamountlow_event\"><code>RTCDataChannel</code>: <code>bufferedamountlow</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/close_event\"><code>RTCDataChannel</code>: <code>close</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/closing_event\"><code>RTCDataChannel</code>: <code>closing</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/error_event\"><code>RTCDataChannel</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/message_event\"><code>RTCDataChannel</code>: <code>message</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/open_event\"><code>RTCDataChannel</code>: <code>open</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport/error_event\"><code>RTCDtlsTransport</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport/statechange_event\"><code>RTCDtlsTransport</code>: <code>statechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/error_event\"><code>RTCIceTransport</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/gatheringstatechange_event\"><code>RTCIceTransport</code>: <code>gatheringstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/selectedcandidatepairchange_event\"><code>RTCIceTransport</code>: <code>selectedcandidatepairchange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/statechange_event\"><code>RTCIceTransport</code>: <code>statechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/connectionstatechange_event\"><code>RTCPeerConnection</code>: <code>connectionstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/datachannel_event\"><code>RTCPeerConnection</code>: <code>datachannel</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\"><code>RTCPeerConnection</code>: <code>icecandidate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidateerror_event\"><code>RTCPeerConnection</code>: <code>icecandidateerror</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/iceconnectionstatechange_event\"><code>RTCPeerConnection</code>: <code>iceconnectionstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\"><code>RTCPeerConnection</code>: <code>icegatheringstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/negotiationneeded_event\"><code>RTCPeerConnection</code>: <code>negotiationneeded</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingstatechange_event\"><code>RTCPeerConnection</code>: <code>signalingstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/track_event\"><code>RTCPeerConnection</code>: <code>track</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSctpTransport/error_event\"><code>RTCSctpTransport</code>: <code>error</code></a></li></ol></details></li></ol>","sidebarMacro":"DefaultAPISidebar","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>WebRTC lets you build peer-to-peer communication of arbitrary data, audio, or video—or any combination thereof—into a browser application. In this article, we'll look at the lifetime of a WebRTC session, from establishing the connection all the way through closing the connection when it's no longer needed.</p>\n<p>This article doesn't get into details of the actual APIs involved in establishing and handling a WebRTC connection; it reviews the process in general with some information about why each step is required. See <a href=\"/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling\">Signaling and video calling</a> for an actual example with a step-by-step explanation of what the code does.</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> This page is currently under construction, and some of the content will move to other pages as the WebRTC guide material is built out. Pardon our dust!</p>\n</div>"}},{"type":"prose","value":{"id":"establishing_the_connection","title":"Establishing the connection","isH3":false,"content":"<p>The internet is big. Really big. It's so big that years ago, smart people saw how big it was, how fast it was growing, and the <a href=\"https://en.wikipedia.org/wiki/IPv4_address_exhaustion\" class=\"external\" target=\"_blank\">limitations</a> of the 32-bit IP addressing system, and realized that something had to be done before we ran out of addresses to use, so they started working on designing a new 64-bit addressing system. But they realized that it would take longer to complete the transition than 32-bit addresses would last, so other smart people came up with a way to let multiple computers share the same 32-bit IP address. Network Address Translation (<a href=\"/en-US/docs/Glossary/NAT\">NAT</a>) is a standard which supports this address sharing by handling routing of data inbound and outbound to and from devices on a LAN, all of which are sharing a single WAN (global) IP address.</p>\n<p>The problem for users is that each individual computer on the internet no longer necessarily has a unique IP address, and, in fact, each device's IP address may change not only if they move from one network to another, but if their network's address is changed by <a href=\"/en-US/docs/Glossary/NAT\">NAT</a> and/or <a href=\"https://en.wikipedia.org/wiki/DHCP\" class=\"external\" target=\"_blank\">DHCP</a>. For developers trying to do peer-to-peer networking, this introduces a conundrum: without a unique identifier for every user device, it's not possible to instantly and automatically know how to connect to a specific device on the internet. Even though you know who you want to talk to, you don't necessarily know how to reach them or even what their address is.</p>\n<p>This is like trying to mail a package to your friend Michelle by labeling it \"Michelle\" and dropping it in a mailbox when you don't know her address. You need to look up her address and include it on the package, or she'll wind up wondering why you forgot her birthday again.</p>\n<p>This is where signaling comes in.</p>"}},{"type":"prose","value":{"id":"signaling","title":"Signaling","isH3":true,"content":"<p>Signaling is the process of sending control information between two devices to determine the communication protocols, channels, media codecs and formats, and method of data transfer, as well as any required routing information. The most important thing to know about the signaling process for WebRTC: <strong>it is not defined in the specification</strong>.</p>\n<p>Why, you may wonder, is something fundamental to the process of establishing a WebRTC connection left out of the specification? The answer is simple: since the two devices have no way to directly contact each other, and the specification can't predict every possible use case for WebRTC, it makes more sense to let the developer select an appropriate networking technology and messaging protocol.</p>\n<p>In particular, if a developer already has a method in place for connecting two devices, it doesn't make sense for them to have to use another one, defined by the specification, just for WebRTC. Since WebRTC doesn't live in a vacuum, there is likely other connectivity in play, so it makes sense to avoid having to add additional connection channels for signaling if an existing one can be used.</p>\n<p>In order to exchange signaling information, you can choose to send JSON objects back and forth over a WebSocket connection, or you could use XMPP or SIP over an appropriate channel, or you could use <a href=\"/en-US/docs/Web/API/fetch\"><code>fetch()</code></a> over <a href=\"/en-US/docs/Glossary/HTTPS\">HTTPS</a> with polling, or any other combination of technologies you can come up with. You could even use email as the signaling channel.</p>\n<p>It's also worth noting that the channel for performing signaling doesn't even need to be over the network. One peer can output a data object that can be printed out, physically carried (on foot or by carrier pigeon) to another device, entered into that device, and a response then output by that device to be returned on foot, and so forth, until the WebRTC peer connection is open. It'd be very high latency but it could be done.</p>\n<h4 id=\"information_exchanged_during_signaling\">Information exchanged during signaling</h4>\n<p>There are three basic types of information that need to be exchanged during signaling:</p>\n<ul>\n  <li>Control messages used to set up, open, and close the communication channel, and to handle errors.</li>\n  <li>Information needed in order to set up the connection: the IP addressing and port information needed for the peers to be able to talk to one another.</li>\n  <li>Media capability negotiation: what codecs and media data formats can the peers understand? These need to be agreed upon before the WebRTC session can begin.</li>\n</ul>\n<p>Only once signaling has been successfully completed can the true process of opening the WebRTC peer connection begin.</p>\n<p>It's worth noting that the signaling server does not actually need to understand or do anything with the data being exchanged through it by the two peers during signaling. The signaling server is, in essence, a relay: a common point which both sides connect to knowing that their signaling data can be transferred through it. The server doesn't need to react to this information in any way.</p>\n<h4 id=\"the_signaling_process\">The signaling process</h4>\n<p>There's a sequence of things that have to happen in order to make it possible to begin a WebRTC session:</p>\n<ol>\n  <li>Each peer creates an <a href=\"/en-US/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> object representing their end of the WebRTC session.</li>\n  <li>Each peer establishes a handler for <a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\" title=\"icecandidate\"><code>icecandidate</code></a> events, which handles sending those candidates to the other peer over the signaling channel.</li>\n  <li>Each peer establishes a handler for <a href=\"/en-US/docs/Web/API/RTCPeerConnection/track_event\" title=\"track\"><code>track</code></a> event, which is received when the remote peer adds a track to the stream. This code should connect the tracks to its consumer, such as a <a href=\"/en-US/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> element.</li>\n  <li>The caller creates and shares with the receiving peer a unique identifier or token of some kind so that the call between them can be identified by the code on the signaling server. The exact contents and form of this identifier is up to you.</li>\n  <li>Each peer connects to an agreed-upon signaling server, such as a WebSocket server they both know how to exchange messages with.</li>\n  <li>Each peer tells the signaling server that they want to join the same WebRTC session (identified by the token established in step 4).</li>\n  <li><strong><em>descriptions, candidates, etc. — more coming up</em></strong></li>\n</ol>"}},{"type":"prose","value":{"id":"ice_restart","title":"ICE restart","isH3":false,"content":"<p>Sometimes, during the lifetime of a WebRTC session, network conditions change. One of the users might transition from a cellular to a Wi-Fi network, or the network might become congested, for example. When this happens, the ICE agent may choose to perform <strong>ICE restart</strong>. This is a process by which the network connection is renegotiated, exactly the same way the initial ICE negotiation is performed, with one exception: media continues to flow across the original network connection until the new one is up and running. Then media shifts to the new network connection and the old one is closed.</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> Different browsers support ICE restart under different sets of conditions. Not all browsers will perform ICE restart due to network congestion, for example.</p>\n</div>\n<p>If you need to change the configuration of the connection in some way (such as changing to a different set of ICE servers), you can do so before restarting ICE by calling <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setConfiguration\"><code>RTCPeerConnection.setConfiguration()</code></a> with an updated configuration object before restarting ICE.</p>\n<p>To explicitly trigger ICE restart, start the renegotiation process by calling <a href=\"/en-US/docs/Web/API/RTCPeerConnection/createOffer\"><code>RTCPeerConnection.createOffer()</code></a>, specifying the <code>iceRestart</code> option with a value of <code>true</code>. Then handle the connection process from then on just like you normally would. This generates new values for the ICE username fragment (ufrag) and password, which will be used by the renegotiation process and the resulting connection.</p>\n<p>The answerer side of the connection will automatically begin ICE restart when new values are detected for the ICE ufrag and ICE password.</p>"}},{"type":"prose","value":{"id":"transmission","title":"Transmission","isH3":false,"content":""}},{"type":"prose","value":{"id":"reception","title":"Reception","isH3":false,"content":""}}],"toc":[{"text":"Establishing the connection","id":"establishing_the_connection"},{"text":"ICE restart","id":"ice_restart"},{"text":"Transmission","id":"transmission"},{"text":"Reception","id":"reception"}],"summary":"WebRTC lets you build peer-to-peer communication of arbitrary data, audio, or video—or any combination thereof—into a browser application. In this article, we'll look at the lifetime of a WebRTC session, from establishing the connection all the way through closing the connection when it's no longer needed.","popularity":0.0046,"modified":"2023-11-09T07:03:33.000Z","source":{"folder":"en-us/web/api/webrtc_api/session_lifetime","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/api/webrtc_api/session_lifetime/index.md","last_commit_url":"https://github.com/mdn/content/commit/7e4769a3d501efb76e7cf92198b0589ab28f1864","filename":"index.md"},"short_title":"Lifetime of a WebRTC session","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/en-US/docs/Web/API/WebRTC_API/Session_lifetime","title":"Lifetime of a WebRTC session"}],"pageTitle":"Lifetime of a WebRTC session - Web APIs | MDN","noIndexing":false}}