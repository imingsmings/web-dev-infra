{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{"macros":[{"id":"macro0","fixable":false,"suggestion":null,"explanation":"/en-US/docs/Web/API/VRCapabilities does not exist","name":"MacroBrokenLinkError","error":{},"errorStack":"Error: /en-US/docs/Web/API/VRCapabilities does not exist\n    at Object.recordNonFatalError (file:///Users/jason/Code/yari/kumascript/src/render.ts:88:13)\n    at Object.smartLink (file:///Users/jason/Code/yari/kumascript/src/api/web.ts:121:29)\n    at eval (\"/Users/jason/Code/yari/kumascript/macros/DOMxRef.ejs\":60:18)\n    at DOMxRef (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:703:17)\n    at /Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:260:40\n    at new Promise (<anonymous>)\n    at tryHandleCache (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:258:14)\n    at exports.renderFile (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:491:10)\n    at Templates.render (file:///Users/jason/Code/yari/kumascript/src/templates.ts:55:40)\n    at render (file:///Users/jason/Code/yari/kumascript/src/render.ts:181:56)","offset":8,"line":67,"column":393,"macroName":"domxref","sourceContext":"  | }\n  | </pre>\n> | <p>This function first uses the promise-based {{domxref(\"Navigator.getVRDisplays()\")}} method, which resolves with an array containing {{domxref(\"VRDisplay\")}} objects representing the connected displays. Next, it prints out each display's {{domxref(\"VRDisplay.displayId\")}} and {{domxref(\"VRDisplay.displayName\")}} values, and a number of useful values contained in the display's associated {{domxref(\"VRCapabilities\")}} object. The most useful of these are {{domxref(\"VRCapabilities.hasOrientation\",\"hasOrientation\")}} and {{domxref(\"VRCapabilities.hasPosition\",\"hasPosition\")}}, which allow you to detect whether the device can return orientation and position data and set up your app accordingly.</p>\n                                                                                                                                                                                                                                                                                                                                                                                                            ^\n  | <p>The last line contained in this function is a {{domxref(\"setTimeout()\")}} call, which runs the <code>reportGamepads()</code> function after a 1 second delay. Why do we need to do this? First of all, VR controllers will only be ready after their associated VR headset is active, so we need to invoke this after <code>getVRDisplays()</code> has been called and returned the display information. Second, the Gamepad API is much older than the WebVR API, and not promise-based. As you'll see later, the <code>getGamepads()</code> method is synchronous, and just returns the <code>Gamepad</code> objects immediately — it doesn't wait for the controller to be ready to report information. Unless you wait for a little while, returned information may not be accurate (at least, this is what we found in our tests).</p>\n  | <h3>Getting the Gamepad information</h3>","fatal":false,"filepath":"/Users/jason/Code/content/files/en-us/web/api/webvr_api/using_vr_controllers_with_webvr/index.md","macroSource":"{{domxref(\"VRCapabilities\")}}"},{"id":"macro1","fixable":false,"suggestion":null,"explanation":"/en-US/docs/Web/API/VRCapabilities/hasOrientation does not exist","name":"MacroBrokenLinkError","error":{},"errorStack":"Error: /en-US/docs/Web/API/VRCapabilities/hasOrientation does not exist\n    at Object.recordNonFatalError (file:///Users/jason/Code/yari/kumascript/src/render.ts:88:13)\n    at Object.smartLink (file:///Users/jason/Code/yari/kumascript/src/api/web.ts:121:29)\n    at eval (\"/Users/jason/Code/yari/kumascript/macros/DOMxRef.ejs\":60:18)\n    at DOMxRef (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:703:17)\n    at /Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:260:40\n    at new Promise (<anonymous>)\n    at tryHandleCache (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:258:14)\n    at exports.renderFile (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:491:10)\n    at Templates.render (file:///Users/jason/Code/yari/kumascript/src/templates.ts:55:40)\n    at render (file:///Users/jason/Code/yari/kumascript/src/render.ts:181:56)","offset":8,"line":67,"column":460,"macroName":"domxref","sourceContext":"  | }\n  | </pre>\n> | <p>This function first uses the promise-based {{domxref(\"Navigator.getVRDisplays()\")}} method, which resolves with an array containing {{domxref(\"VRDisplay\")}} objects representing the connected displays. Next, it prints out each display's {{domxref(\"VRDisplay.displayId\")}} and {{domxref(\"VRDisplay.displayName\")}} values, and a number of useful values contained in the display's associated {{domxref(\"VRCapabilities\")}} object. The most useful of these are {{domxref(\"VRCapabilities.hasOrientation\",\"hasOrientation\")}} and {{domxref(\"VRCapabilities.hasPosition\",\"hasPosition\")}}, which allow you to detect whether the device can return orientation and position data and set up your app accordingly.</p>\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^\n  | <p>The last line contained in this function is a {{domxref(\"setTimeout()\")}} call, which runs the <code>reportGamepads()</code> function after a 1 second delay. Why do we need to do this? First of all, VR controllers will only be ready after their associated VR headset is active, so we need to invoke this after <code>getVRDisplays()</code> has been called and returned the display information. Second, the Gamepad API is much older than the WebVR API, and not promise-based. As you'll see later, the <code>getGamepads()</code> method is synchronous, and just returns the <code>Gamepad</code> objects immediately — it doesn't wait for the controller to be ready to report information. Unless you wait for a little while, returned information may not be accurate (at least, this is what we found in our tests).</p>\n  | <h3>Getting the Gamepad information</h3>","fatal":false,"filepath":"/Users/jason/Code/content/files/en-us/web/api/webvr_api/using_vr_controllers_with_webvr/index.md","macroSource":"{{domxref(\"VRCapabilities.hasOrientation\",\"hasOrientation\")}}"},{"id":"macro2","fixable":false,"suggestion":null,"explanation":"/en-US/docs/Web/API/VRCapabilities/hasPosition does not exist","name":"MacroBrokenLinkError","error":{},"errorStack":"Error: /en-US/docs/Web/API/VRCapabilities/hasPosition does not exist\n    at Object.recordNonFatalError (file:///Users/jason/Code/yari/kumascript/src/render.ts:88:13)\n    at Object.smartLink (file:///Users/jason/Code/yari/kumascript/src/api/web.ts:121:29)\n    at eval (\"/Users/jason/Code/yari/kumascript/macros/DOMxRef.ejs\":60:18)\n    at DOMxRef (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:703:17)\n    at /Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:260:40\n    at new Promise (<anonymous>)\n    at tryHandleCache (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:258:14)\n    at exports.renderFile (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:491:10)\n    at Templates.render (file:///Users/jason/Code/yari/kumascript/src/templates.ts:55:40)\n    at render (file:///Users/jason/Code/yari/kumascript/src/render.ts:181:56)","offset":8,"line":67,"column":526,"macroName":"domxref","sourceContext":"  | }\n  | </pre>\n> | <p>This function first uses the promise-based {{domxref(\"Navigator.getVRDisplays()\")}} method, which resolves with an array containing {{domxref(\"VRDisplay\")}} objects representing the connected displays. Next, it prints out each display's {{domxref(\"VRDisplay.displayId\")}} and {{domxref(\"VRDisplay.displayName\")}} values, and a number of useful values contained in the display's associated {{domxref(\"VRCapabilities\")}} object. The most useful of these are {{domxref(\"VRCapabilities.hasOrientation\",\"hasOrientation\")}} and {{domxref(\"VRCapabilities.hasPosition\",\"hasPosition\")}}, which allow you to detect whether the device can return orientation and position data and set up your app accordingly.</p>\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^\n  | <p>The last line contained in this function is a {{domxref(\"setTimeout()\")}} call, which runs the <code>reportGamepads()</code> function after a 1 second delay. Why do we need to do this? First of all, VR controllers will only be ready after their associated VR headset is active, so we need to invoke this after <code>getVRDisplays()</code> has been called and returned the display information. Second, the Gamepad API is much older than the WebVR API, and not promise-based. As you'll see later, the <code>getGamepads()</code> method is synchronous, and just returns the <code>Gamepad</code> objects immediately — it doesn't wait for the controller to be ready to report information. Unless you wait for a little while, returned information may not be accurate (at least, this is what we found in our tests).</p>\n  | <h3>Getting the Gamepad information</h3>","fatal":false,"filepath":"/Users/jason/Code/content/files/en-us/web/api/webvr_api/using_vr_controllers_with_webvr/index.md","macroSource":"{{domxref(\"VRCapabilities.hasPosition\",\"hasPosition\")}}"}]},"title":"Using VR controllers with WebVR","mdn_url":"/en-US/docs/Web/API/WebVR_API/Using_VR_controllers_with_WebVR","locale":"en-US","native":"English (US)","summary":"This article has given you a very basic idea of how to use the Gamepad Extensions to use VR controllers inside WebVR apps. In a real app you'd probably have a much more complex control system in effect, with controls assigned to the buttons on the VR controllers, and the display being affected by both the display pose and the controller poses simultaneously. Here however, we just wanted to isolate the pure Gamepad Extensions parts of that.","popularity":0,"modified":"2023-07-07T07:19:19.000Z","source":{"folder":"en-us/web/api/webvr_api/using_vr_controllers_with_webvr","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/api/webvr_api/using_vr_controllers_with_webvr/index.md","last_commit_url":"https://github.com/mdn/content/commit/acfe8c9f1f4145f77653a2bc64a9744b001358dc","filename":"index.md"},"short_title":"Using VR controllers with WebVR","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebVR_API","title":"WebVR API"},{"uri":"/en-US/docs/Web/API/WebVR_API/Using_VR_controllers_with_WebVR","title":"Using VR controllers with WebVR"}],"pageTitle":"Using VR controllers with WebVR - Web APIs | MDN","noIndexing":false,"hash":"772559a8e4bc1f590979613472428320030a612048684df7e7043bd0894ef3dc"}