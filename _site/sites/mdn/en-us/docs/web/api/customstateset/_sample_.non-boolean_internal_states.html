<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="robots" content="noindex, nofollow">
        <style>
            body {
              padding: 0;
              margin: 0;
            }

            svg:not(:root) {
              display: block;
            }

            .playable-code {
              background-color: #f4f7f8;
              border: none;
              border-left: 6px solid #558abb;
              border-width: medium medium medium 6px;
              color: #4d4e53;
              height: 100px;
              width: 90%;
              padding: 10px 10px 0;
            }

            .playable-canvas {
              border: 1px solid #4d4e53;
              border-radius: 2px;
            }

            .playable-buttons {
              text-align: right;
              width: 90%;
              padding: 5px 10px 5px 26px;
            }
        </style>
        
        <style>
            many-state-element:--loading {
  border: dotted grey;
}
many-state-element:--interactive {
  border: dashed blue;
}
many-state-element:--complete {
  border: solid green;
}

        </style>
        
        <title>CustomStateSet - non-boolean_internal_states - code sample</title>
        
    </head>
    <body>
        
            <many-state-element></many-state-element>

        
        
            <script>
                class ManyStateElement extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    // Attach an ElementInternals to get states property
    this._internals = this.attachInternals();
    this.state = "loading";
    this.addEventListener("click", this._onClick.bind(this));

    const shadowRoot = this.attachShadow({ mode: "open" });
    shadowRoot.innerHTML = `<style>
        :host {
          display: block;
          font-family: monospace;
        }
       :host::before { content: '[ unknown ]'; white-space: pre; }
       :host(:--loading)::before { content: '[ loading ]' }
       :host(:--interactive)::before { content: '[ interactive ]' }
       :host(:--complete)::before { content: '[ complete ]' }
       </style>
       <slot>Click me</slot>`;
  }

  get state() {
    return this._state;
  }

  set state(stateName) {
    // Set internal state to passed value
    // Add dashed identifier matching state and delete others
    if (stateName == "loading") {
      this._state = "loading";
      this._internals.states.add("--loading");
      this._internals.states.delete("--interactive");
      this._internals.states.delete("--complete");
    } else if (stateName == "interactive") {
      this._state = "interactive";
      this._internals.states.delete("--loading");
      this._internals.states.add("--interactive");
      this._internals.states.delete("--complete");
    } else if (stateName == "complete") {
      this._state = "complete";
      this._internals.states.delete("--loading");
      this._internals.states.delete("--interactive");
      this._internals.states.add("--complete");
    }
  }

  _onClick(event) {
    // Cycle the state when element clicked
    if (this.state === "loading") {
      this.state = "interactive";
    } else if (this.state === "interactive") {
      this.state = "complete";
    } else if (this.state === "complete") {
      this.state = "loading";
    }
  }
}

customElements.define("many-state-element", ManyStateElement);

            </script>
        
    </body>
</html>