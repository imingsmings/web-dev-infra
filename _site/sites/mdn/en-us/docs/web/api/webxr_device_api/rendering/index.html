<!doctype html><html lang="en-US" prefix="og: https://ogp.me/ns#"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><link rel="icon" href="/favicon-48x48.cbbd161b.png"/><link rel="apple-touch-icon" href="/apple-touch-icon.6803c6f0.png"/><meta name="theme-color" content="#ffffff"/><link rel="manifest" href="/manifest.56b1cedc.json"/><link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="MDN Web Docs"/><title>Rendering and the WebXR frame animation callback - Web APIs | MDN</title><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en" /><meta name="robots" content="noindex, nofollow"><meta name="description" content="Once your WebXR environment has been set up and an XRSession created to represent an ongoing XR environment session, you need to provide frames of the scene to the XR device for rendering. This article covers the process of driving the frames of the XR scene to the device in the rendering loop, using the XRSession to obtain an XRFrame object representing each frame, which is then used to prepare the framebuffer for delivery to the XR device."/><meta property="og:url" content="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Rendering"/><meta property="og:title" content="Rendering and the WebXR frame animation callback - Web APIs | MDN"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:description" content="Once your WebXR environment has been set up and an XRSession created to represent an ongoing XR environment session, you need to provide frames of the scene to the XR device for rendering. This article covers the process of driving the frames of the XR scene to the device in the rendering loop, using the XRSession to obtain an XRFrame object representing each frame, which is then used to prepare the framebuffer for delivery to the XR device."/><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:height" content="1080"/><meta property="og:image:width" content="1920"/><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."/><meta property="og:site_name" content="MDN Web Docs"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:creator" content="MozDevNet"/><link rel="canonical" href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Rendering"/><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><script defer="defer" src="/static/js/main.8204838d.js"></script><link href="/static/css/main.3551aa81.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e])}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><ul id="nav-access" class="a11y-nav"><li><a id="skip-main" href="#content">Skip to main content</a></li><li><a id="skip-search" href="#top-nav-search-input">Skip to search</a></li><li><a id="skip-select-language" href="#languages-switcher-button">Skip to select language</a></li></ul><div class="page-wrapper  category-api document-page"><div class="top-banner loading"><section class="place top container"></section></div><div class="sticky-header-container"><header class="top-navigation 
      
      "><div class="container "><div class="top-navigation-wrap"><a href="/en-US/" class="logo" aria-label="MDN homepage"><svg id="mdn-docs-logo" xmlns="http://www.w3.org/2000/svg" x="0" y="0" viewBox="0 0 694.9 104.4" style="enable-background:new 0 0 694.9 104.4" xml:space="preserve" role="img"><title>MDN Web Docs</title><path d="M40.3 0 11.7 92.1H0L28.5 0h11.8zm10.4 0v92.1H40.3V0h10.4zM91 0 62.5 92.1H50.8L79.3 0H91zm10.4 0v92.1H91V0h10.4z" class="logo-m"></path><path d="M627.9 95.6h67v8.8h-67v-8.8z" class="logo-_"></path><path d="M367 42h-4l-10.7 30.8h-5.5l-10.8-26h-.4l-10.5 26h-5.2L308.7 42h-3.8v-5.6H323V42h-6.5l6.8 20.4h.4l10.3-26h4.7l11.2 26h.5l5.7-20.3h-6.2v-5.6H367V42zm34.9 20c-.4 3.2-2 5.9-4.7 8.2-2.8 2.3-6.5 3.4-11.3 3.4-5.4 0-9.7-1.6-13.1-4.7-3.3-3.2-5-7.7-5-13.7 0-5.7 1.6-10.3 4.7-14s7.4-5.5 12.9-5.5c5.1 0 9.1 1.6 11.9 4.7s4.3 6.9 4.3 11.3c0 1.5-.2 3-.5 4.7h-25.6c.3 7.7 4 11.6 10.9 11.6 2.9 0 5.1-.7 6.5-2 1.5-1.4 2.5-3 3-4.9l6 .9zM394 51.3c.2-2.4-.4-4.7-1.8-6.9s-3.8-3.3-7-3.3c-3.1 0-5.3 1-6.9 3-1.5 2-2.5 4.4-2.8 7.2H394zm51 2.4c0 5-1.3 9.5-4 13.7s-6.9 6.2-12.7 6.2c-6 0-10.3-2.2-12.7-6.7-.1.4-.2 1.4-.4 2.9s-.3 2.5-.4 2.9h-7.3c.3-1.7.6-3.5.8-5.3.3-1.8.4-3.7.4-5.5V22.3h-6v-5.6H416v27c1.1-2.2 2.7-4.1 4.7-5.7 2-1.6 4.8-2.4 8.4-2.4 4.6 0 8.4 1.6 11.4 4.7 3 3.2 4.5 7.6 4.5 13.4zm-7.7.6c0-4.2-1-7.4-3-9.5-2-2.2-4.4-3.3-7.4-3.3-3.4 0-6 1.2-8 3.7-1.9 2.4-2.9 5-3 7.7V57c0 3 1 5.6 3 7.7s4.5 3.1 7.6 3.1c3.6 0 6.3-1.3 8.1-3.9 1.8-2.7 2.7-5.9 2.7-9.6zm69.2 18.5h-13.2v-7.2c-1.2 2.2-2.8 4.1-4.9 5.6-2.1 1.6-4.8 2.4-8.3 2.4-4.8 0-8.7-1.6-11.6-4.9-2.9-3.2-4.3-7.7-4.3-13.3 0-5 1.3-9.6 4-13.7 2.6-4.1 6.9-6.2 12.8-6.2 5.7 0 9.8 2.2 12.3 6.5V22.3h-8.6v-5.6h15.8v50.6h6v5.5zM493.2 56v-4.4c-.1-3-1.2-5.5-3.2-7.3s-4.4-2.8-7.2-2.8c-3.6 0-6.3 1.3-8.2 3.9-1.9 2.6-2.8 5.8-2.8 9.6 0 4.1 1 7.3 3 9.5s4.5 3.3 7.4 3.3c3.2 0 5.8-1.3 7.8-3.8 2.1-2.6 3.1-5.3 3.2-8zm53.1-1.4c0 5.6-1.8 10.2-5.3 13.7s-8.2 5.3-13.9 5.3-10.1-1.7-13.4-5.1c-3.3-3.4-5-7.9-5-13.5 0-5.3 1.6-9.9 4.7-13.7 3.2-3.8 7.9-5.7 14.2-5.7s11 1.9 14.1 5.7c3 3.7 4.6 8.1 4.6 13.3zm-7.7-.2c0-4-1-7.2-3-9.5s-4.8-3.5-8.2-3.5c-3.6 0-6.4 1.2-8.3 3.7s-2.9 5.6-2.9 9.5c0 3.7.9 6.8 2.8 9.4 1.9 2.6 4.6 3.9 8.3 3.9 3.6 0 6.4-1.3 8.4-3.8 1.9-2.6 2.9-5.8 2.9-9.7zm45 5.8c-.4 3.2-1.9 6.3-4.4 9.1-2.5 2.9-6.4 4.3-11.8 4.3-5.2 0-9.4-1.6-12.6-4.8-3.2-3.2-4.8-7.7-4.8-13.7 0-5.5 1.6-10.1 4.7-13.9 3.2-3.8 7.6-5.7 13.2-5.7 2.3 0 4.6.3 6.7.8 2.2.5 4.2 1.5 6.2 2.9l1.5 9.5-5.9.7-1.3-6.1c-2.1-1.2-4.5-1.8-7.2-1.8-3.5 0-6.1 1.2-7.7 3.7-1.7 2.5-2.5 5.7-2.5 9.6 0 4.1.9 7.3 2.7 9.5 1.8 2.3 4.4 3.4 7.8 3.4 5.2 0 8.2-2.9 9.2-8.8l6.2 1.3zm34.7 1.9c0 3.6-1.5 6.5-4.6 8.5s-7 3-11.7 3c-5.7 0-10.6-1.2-14.6-3.6l1.2-8.8 5.7.6-.2 4.7c1.1.5 2.3.9 3.6 1.1s2.6.3 3.9.3c2.4 0 4.5-.4 6.5-1.3 1.9-.9 2.9-2.2 2.9-4.1 0-1.8-.8-3.1-2.3-3.8s-3.5-1.3-5.8-1.7-4.6-.9-6.9-1.4c-2.3-.6-4.2-1.6-5.7-2.9-1.6-1.4-2.3-3.5-2.3-6.3 0-4.1 1.5-6.9 4.6-8.5s6.4-2.4 9.9-2.4c2.6 0 5 .3 7.2.9 2.2.6 4.3 1.4 6.1 2.4l.8 8.8-5.8.7-.8-5.7c-2.3-1-4.7-1.6-7.2-1.6-2.1 0-3.7.4-5.1 1.1-1.3.8-2 2-2 3.8 0 1.7.8 2.9 2.3 3.6 1.5.7 3.4 1.2 5.7 1.6 2.2.4 4.5.8 6.7 1.4 2.2.6 4.1 1.6 5.7 3 1.4 1.6 2.2 3.7 2.2 6.6zM197.6 73.2h-17.1v-5.5h3.8V51.9c0-3.7-.7-6.3-2.1-7.9-1.4-1.6-3.3-2.3-5.7-2.3-3.2 0-5.6 1.1-7.2 3.4s-2.4 4.6-2.5 6.9v15.6h6v5.5h-17.1v-5.5h3.8V51.9c0-3.8-.7-6.4-2.1-7.9-1.4-1.5-3.3-2.3-5.6-2.3-3.2 0-5.5 1.1-7.2 3.3-1.6 2.2-2.4 4.5-2.5 6.9v15.8h6.9v5.5h-20.2v-5.5h6V42.4h-6.1v-5.6h13.4v6.4c1.2-2.1 2.7-3.8 4.7-5.2 2-1.3 4.4-2 7.3-2s5.3.7 7.5 2.1c2.2 1.4 3.7 3.5 4.5 6.4 1.1-2.5 2.7-4.5 4.9-6.1s4.8-2.4 7.9-2.4c3.5 0 6.5 1.1 8.9 3.3s3.7 5.6 3.7 10.2v18.2h6.1v5.5zm42.5 0h-13.2V66c-1.2 2.2-2.8 4.1-4.9 5.6-2.1 1.6-4.8 2.4-8.3 2.4-4.8 0-8.7-1.6-11.6-4.9-2.9-3.2-4.3-7.7-4.3-13.3 0-5 1.3-9.6 4-13.7 2.6-4.1 6.9-6.2 12.8-6.2s9.8 2.2 12.3 6.5V22.7h-8.6v-5.6h15.8v50.6h6v5.5zm-13.3-16.8V52c-.1-3-1.2-5.5-3.2-7.3s-4.4-2.8-7.2-2.8c-3.6 0-6.3 1.3-8.2 3.9-1.9 2.6-2.8 5.8-2.8 9.6 0 4.1 1 7.3 3 9.5s4.5 3.3 7.4 3.3c3.2 0 5.8-1.3 7.8-3.8 2.1-2.6 3.1-5.3 3.2-8zm61.5 16.8H269v-5.5h6V51.9c0-3.7-.7-6.3-2.2-7.9-1.4-1.6-3.4-2.3-5.7-2.3-3.1 0-5.6 1-7.4 3s-2.8 4.4-2.9 7v15.9h6v5.5h-19.3v-5.5h6V42.4h-6.2v-5.6h13.6V43c2.6-4.6 6.8-6.9 12.7-6.9 3.6 0 6.7 1.1 9.2 3.3s3.7 5.6 3.7 10.2v18.2h6v5.4h-.2z" class="logo-text"></path></svg></a><button title="Open main menu" type="button" class="button action has-icon main-menu-toggle" aria-haspopup="menu" aria-label="Open main menu" aria-expanded="false"><span class="button-wrap"><span class="icon icon-menu "></span><span class="visually-hidden">Open main menu</span></span></button></div><div class="top-navigation-main"><nav class="main-nav" aria-label="Main menu"><ul class="main-menu nojs"><li class="top-level-entry-container active"><button type="button" id="references-button" class="top-level-entry menu-toggle" aria-controls="references-menu" aria-expanded="false">References</button><a href="/en-US/docs/Web" class="top-level-entry">References</a><ul id="references-menu" class="submenu references hidden inline-submenu-lg" aria-labelledby="references-button"><li class="apis-link-container mobile-only "><a href="/en-US/docs/Web" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Overview / Web Technology</div><p class="submenu-item-description">Web technology reference for developers</p></div></a></li><li class="html-link-container "><a href="/en-US/docs/Web/HTML" class="submenu-item "><div class="submenu-icon html"></div><div class="submenu-content-container"><div class="submenu-item-heading">HTML</div><p class="submenu-item-description">Structure of content on the web</p></div></a></li><li class="css-link-container "><a href="/en-US/docs/Web/CSS" class="submenu-item "><div class="submenu-icon css"></div><div class="submenu-content-container"><div class="submenu-item-heading">CSS</div><p class="submenu-item-description">Code used to describe document style</p></div></a></li><li class="javascript-link-container "><a href="/en-US/docs/Web/JavaScript" class="submenu-item "><div class="submenu-icon javascript"></div><div class="submenu-content-container"><div class="submenu-item-heading">JavaScript</div><p class="submenu-item-description">General-purpose scripting language</p></div></a></li><li class="http-link-container "><a href="/en-US/docs/Web/HTTP" class="submenu-item "><div class="submenu-icon http"></div><div class="submenu-content-container"><div class="submenu-item-heading">HTTP</div><p class="submenu-item-description">Protocol for transmitting web resources</p></div></a></li><li class="apis-link-container "><a href="/en-US/docs/Web/API" class="submenu-item "><div class="submenu-icon apis"></div><div class="submenu-content-container"><div class="submenu-item-heading">Web APIs</div><p class="submenu-item-description">Interfaces for building web applications</p></div></a></li><li class="apis-link-container "><a href="/en-US/docs/Mozilla/Add-ons/WebExtensions" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Web Extensions</div><p class="submenu-item-description">Developing extensions for web browsers</p></div></a></li><li class="apis-link-container desktop-only "><a href="/en-US/docs/Web" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Web Technology</div><p class="submenu-item-description">Web technology reference for developers</p></div></a></li></ul></li><li class="top-level-entry-container "><button type="button" id="guides-button" class="top-level-entry menu-toggle" aria-controls="guides-menu" aria-expanded="false">Guides</button><a href="/en-US/docs/Learn" class="top-level-entry">Guides</a><ul id="guides-menu" class="submenu guides hidden inline-submenu-lg" aria-labelledby="guides-button"><li class="apis-link-container mobile-only "><a href="/en-US/docs/Learn" class="submenu-item "><div class="submenu-icon learn"></div><div class="submenu-content-container"><div class="submenu-item-heading">Overview / MDN Learning Area</div><p class="submenu-item-description">Learn web development</p></div></a></li><li class="apis-link-container desktop-only "><a href="/en-US/docs/Learn" class="submenu-item "><div class="submenu-icon learn"></div><div class="submenu-content-container"><div class="submenu-item-heading">MDN Learning Area</div><p class="submenu-item-description">Learn web development</p></div></a></li><li class="html-link-container "><a href="/en-US/docs/Learn/HTML" class="submenu-item "><div class="submenu-icon html"></div><div class="submenu-content-container"><div class="submenu-item-heading">HTML</div><p class="submenu-item-description">Learn to structure web content with HTML</p></div></a></li><li class="css-link-container "><a href="/en-US/docs/Learn/CSS" class="submenu-item "><div class="submenu-icon css"></div><div class="submenu-content-container"><div class="submenu-item-heading">CSS</div><p class="submenu-item-description">Learn to style content using CSS</p></div></a></li><li class="javascript-link-container "><a href="/en-US/docs/Learn/JavaScript" class="submenu-item "><div class="submenu-icon javascript"></div><div class="submenu-content-container"><div class="submenu-item-heading">JavaScript</div><p class="submenu-item-description">Learn to run scripts in the browser</p></div></a></li><li class=" "><a href="/en-US/docs/Web/Accessibility" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Accessibility</div><p class="submenu-item-description">Learn to make the web accessible to all</p></div></a></li></ul></li><li class="top-level-entry-container "><a class="top-level-entry menu-link" href="/en-US/blog/">Blog</a></li><li class="top-level-entry-container "><a class="top-level-entry menu-link" href="/en-US/play">Play</a></li><li class="top-level-entry-container "><a class="top-level-entry menu-link" href="/en-US/plus/ai-help">AI Help <sup class="new beta">Beta</sup></a></li></ul></nav><div class="header-search"><form action="/en-US/search" class="search-form search-widget" id="top-nav-search-form" role="search"><label id="top-nav-search-label" for="top-nav-search-input" class="visually-hidden">Search MDN</label><input aria-activedescendant="" aria-autocomplete="list" aria-controls="top-nav-search-menu" aria-expanded="false" aria-labelledby="top-nav-search-label" autoComplete="off" id="top-nav-search-input" role="combobox" type="search" class="search-input-field" name="q" placeholder="   " required="" value=""/><button type="button" class="button action has-icon clear-search-button"><span class="button-wrap"><span class="icon icon-cancel "></span><span class="visually-hidden">Clear search input</span></span></button><button type="submit" class="button action has-icon search-button"><span class="button-wrap"><span class="icon icon-search "></span><span class="visually-hidden">Search</span></span></button><div id="top-nav-search-menu" role="listbox" aria-labelledby="top-nav-search-label"></div></form></div><div class="theme-switcher-menu"><button type="button" class="button action has-icon theme-switcher-menu small" aria-haspopup="menu"><span class="button-wrap"><span class="icon icon-theme-os-default "></span>Theme</span></button></div><ul class="auth-container"><li><a href="?next=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebXR_Device_API%2FRendering" class="login-link" rel="nofollow">Log in</a></li><li><a href="?next=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebXR_Device_API%2FRendering" target="_self" class="button primary mdn-plus-subscribe-link"><span class="button-wrap">Sign up for free</span></a></li></ul></div></div></header><div class="article-actions-container"><div class="container"><button type="button" class="button action has-icon sidebar-button" aria-label="Expand sidebar" aria-expanded="false" aria-controls="sidebar-quicklinks"><span class="button-wrap"><span class="icon icon-sidebar "></span></span></button><nav class="breadcrumbs-container" aria-label="Breadcrumb"><ol typeof="BreadcrumbList" vocab="https://schema.org/" aria-label="breadcrumbs"><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="/en-US/docs/Web"><span property="name">References</span></a><meta property="position" content="1"/></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="/en-US/docs/Web/API"><span property="name">Web APIs</span></a><meta property="position" content="2"/></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="/en-US/docs/Web/API/WebXR_Device_API"><span property="name">WebXR Device API</span></a><meta property="position" content="3"/></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb-current-page" property="item" typeof="WebPage" href="/en-US/docs/Web/API/WebXR_Device_API/Rendering"><span property="name">Rendering and the WebXR frame animation callback</span></a><meta property="position" content="4"/></li></ol></nav></div></div></div><div class="main-wrapper"><div class="sidebar-container"><aside id="sidebar-quicklinks" class="sidebar" data-macro="DefaultAPISidebar"><button type="button" class="button action backdrop" aria-label="Collapse sidebar"><span class="button-wrap"></span></button><nav aria-label="Related Topics" class="sidebar-inner"><header class="sidebar-actions"><section class="sidebar-filter-container"><div class="sidebar-filter "><label id="sidebar-filter-label" class="sidebar-filter-label" for="sidebar-filter-input"><span class="icon icon-filter"></span><span class="visually-hidden">Filter sidebar</span></label><input id="sidebar-filter-input" autoComplete="off" class="sidebar-filter-input-field false" type="text" placeholder="Filter" value=""/><button type="button" class="button action has-icon clear-sidebar-filter-button"><span class="button-wrap"><span class="icon icon-cancel "></span><span class="visually-hidden">Clear filter input</span></span></button></div></section></header><div class="sidebar-inner-nav"><div class="in-nav-toc"><div class="document-toc-container"><section class="document-toc"><header><h2 class="document-toc-heading">In this article</h2></header><ul class="document-toc-list"><li class="document-toc-item "><a class="document-toc-link" href="#preparing_the_renderer">Preparing the renderer</a></li><li class="document-toc-item "><a class="document-toc-link" href="#refresh_rate_and_frame_rate">Refresh rate and frame rate</a></li><li class="document-toc-item "><a class="document-toc-link" href="#webxr_frames">WebXR frames</a></li><li class="document-toc-item "><a class="document-toc-link" href="#drawing_the_scene">Drawing the scene</a></li><li class="document-toc-item "><a class="document-toc-link" href="#additional_tasks_related_to_animating_the_scene">Additional tasks related to animating the scene</a></li><li class="document-toc-item "><a class="document-toc-link" href="#next_steps">Next steps</a></li><li class="document-toc-item "><a class="document-toc-link" href="#see_also">See also</a></li></ul></section></div></div><div class="sidebar-body"><ol><li><strong><a href="/en-US/docs/Web/API/WebXR_Device_API">WebXR Device API</a></strong></li><li class="toggle"><details open=""><summary>Guides</summary><ol><li><a href="/en-US/docs/Web/API/WebXR_Device_API/Fundamentals">Fundamentals of WebXR</a></li><li><a href="/en-US/docs/Web/API/WebXR_Device_API/Lifecycle">WebXR application life cycle</a></li><li><a href="/en-US/docs/Web/API/WebXR_Device_API/Startup_and_shutdown">Starting up and shutting down a WebXR session</a></li><li><a href="/en-US/docs/Web/API/WebXR_Device_API/Cameras">Viewpoints and viewers: Simulating cameras in WebXR</a></li><li><a href="/en-US/docs/Web/API/WebXR_Device_API/Geometry">Geometry and reference spaces in WebXR</a></li><li><a href="/en-US/docs/Web/API/WebXR_Device_API/Spatial_tracking">Spaces and reference spaces: Spatial tracking in WebXR</a></li></ol></details></li><li class="toggle"><details open=""><summary>Interfaces</summary><ol><li><a href="/en-US/docs/Web/API/XRAnchor"><code>XRAnchor</code></a></li><li><a href="/en-US/docs/Web/API/XRBoundedReferenceSpace"><code>XRBoundedReferenceSpace</code></a></li><li><a href="/en-US/docs/Web/API/XRCPUDepthInformation"><code>XRCPUDepthInformation</code></a></li><li><a href="/en-US/docs/Web/API/XRDepthInformation"><code>XRDepthInformation</code></a></li><li><a href="/en-US/docs/Web/API/XRFrame"><code>XRFrame</code></a></li><li><a href="/en-US/docs/Web/API/XRInputSource"><code>XRInputSource</code></a></li><li><a href="/en-US/docs/Web/API/XRInputSourceArray"><code>XRInputSourceArray</code></a></li><li><a href="/en-US/docs/Web/API/XRInputSourceEvent"><code>XRInputSourceEvent</code></a></li><li><a href="/en-US/docs/Web/API/XRInputSourcesChangeEvent"><code>XRInputSourcesChangeEvent</code></a></li><li><a href="/en-US/docs/Web/API/XRPose"><code>XRPose</code></a></li><li><a href="/en-US/docs/Web/API/XRReferenceSpace"><code>XRReferenceSpace</code></a></li><li><a href="/en-US/docs/Web/API/XRReferenceSpaceEvent"><code>XRReferenceSpaceEvent</code></a></li><li><a href="/en-US/docs/Web/API/XRRenderState"><code>XRRenderState</code></a></li><li><a href="/en-US/docs/Web/API/XRRigidTransform"><code>XRRigidTransform</code></a></li><li><a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a></li><li><a href="/en-US/docs/Web/API/XRSessionEvent"><code>XRSessionEvent</code></a></li><li><a href="/en-US/docs/Web/API/XRSpace"><code>XRSpace</code></a></li><li><a href="/en-US/docs/Web/API/XRSystem"><code>XRSystem</code></a></li><li><a href="/en-US/docs/Web/API/XRView"><code>XRView</code></a></li><li><a href="/en-US/docs/Web/API/XRViewerPose"><code>XRViewerPose</code></a></li><li><a href="/en-US/docs/Web/API/XRViewport"><code>XRViewport</code></a></li><li><a href="/en-US/docs/Web/API/XRWebGLBinding"><code>XRWebGLBinding</code></a></li><li><a href="/en-US/docs/Web/API/XRWebGLDepthInformation"><code>XRWebGLDepthInformation</code></a></li><li><a href="/en-US/docs/Web/API/XRWebGLLayer"><code>XRWebGLLayer</code></a></li></ol></details></li><li class="toggle"><details open=""><summary>Properties</summary><ol><li><a href="/en-US/docs/Web/API/Navigator/xr"><code>Navigator.xr</code></a></li></ol></details></li><li class="toggle"><details open=""><summary>Methods</summary><ol><li><a href="/en-US/docs/Web/API/WebGLRenderingContext/makeXRCompatible"><code>WebGLRenderingContext.makeXRCompatible()</code></a></li></ol></details></li><li class="toggle"><details open=""><summary>Events</summary><ol><li><a href="/en-US/docs/Web/API/XRReferenceSpace/reset_event"><code>XRReferenceSpace</code>: <code>reset</code></a></li><li><a href="/en-US/docs/Web/API/XRSession/end_event"><code>XRSession</code>: <code>end</code></a></li><li><a href="/en-US/docs/Web/API/XRSession/inputsourceschange_event"><code>XRSession</code>: <code>inputsourceschange</code></a></li><li><a href="/en-US/docs/Web/API/XRSession/select_event"><code>XRSession</code>: <code>select</code></a></li><li><a href="/en-US/docs/Web/API/XRSession/selectend_event"><code>XRSession</code>: <code>selectend</code></a></li><li><a href="/en-US/docs/Web/API/XRSession/selectstart_event"><code>XRSession</code>: <code>selectstart</code></a></li><li><a href="/en-US/docs/Web/API/XRSession/visibilitychange_event"><code>XRSession</code>: <code>visibilitychange</code></a></li><li><a href="/en-US/docs/Web/API/XRSystem/devicechange_event"><code>XRSystem</code>: <code>devicechange</code></a></li></ol></details></li></ol></div></div></nav></aside><div class="toc-container"><aside class="toc"><nav><div class="document-toc-container"><section class="document-toc"><header><h2 class="document-toc-heading">In this article</h2></header><ul class="document-toc-list"><li class="document-toc-item "><a class="document-toc-link" href="#preparing_the_renderer">Preparing the renderer</a></li><li class="document-toc-item "><a class="document-toc-link" href="#refresh_rate_and_frame_rate">Refresh rate and frame rate</a></li><li class="document-toc-item "><a class="document-toc-link" href="#webxr_frames">WebXR frames</a></li><li class="document-toc-item "><a class="document-toc-link" href="#drawing_the_scene">Drawing the scene</a></li><li class="document-toc-item "><a class="document-toc-link" href="#additional_tasks_related_to_animating_the_scene">Additional tasks related to animating the scene</a></li><li class="document-toc-item "><a class="document-toc-link" href="#next_steps">Next steps</a></li><li class="document-toc-item "><a class="document-toc-link" href="#see_also">See also</a></li></ul></section></div></nav></aside></div></div><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>Rendering and the WebXR frame animation callback</h1></header><div class="section-content"><p>Once your WebXR environment has been set up and an <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> created to represent an ongoing XR environment session, you need to provide frames of the scene to the XR device for rendering. This article covers the process of driving the frames of the XR scene to the device in the rendering loop, using the <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> to obtain an <a href="/en-US/docs/Web/API/XRFrame"><code>XRFrame</code></a> object representing each frame, which is then used to prepare the framebuffer for delivery to the XR device.</p>
<p>Before you can render the virtual environment, you need to establish a WebXR session by creating an <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> using the <a href="/en-US/docs/Web/API/XRSystem/requestSession"><code>navigator.xr.requestSession()</code></a> method; you also need to associate the session with a framebuffer and perform other setup tasks. These setup tasks are described in the article <a href="/en-US/docs/Web/API/WebXR_Device_API/Startup_and_shutdown">Starting up and shutting down a WebXR session</a>.</p></div><section aria-labelledby="preparing_the_renderer"><h2 id="preparing_the_renderer"><a href="#preparing_the_renderer">Preparing the renderer</a></h2><div class="section-content"><p>Once the XR session has been set up, with the WebGL framebuffer connected and WebGL primed with the data it needs in order to render the scene, you can set up the renderer to start running. This begins with getting the reference space in which you want to draw, with its origin and orientation set at the viewer's starting position and viewing direction. Once that's in hand, you request that the browser call your rendering function the next time it needs a framebuffer to render your scene. This is done by calling the <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> method <a href="/en-US/docs/Web/API/XRSession/requestAnimationFrame" title="requestAnimationFrame()"><code>requestAnimationFrame()</code></a>.</p>
<p>Kicking off the renderer thus looks like this:</p>
<div class="code-example"><p class="example-header"><span class="language-name">js</span></p><pre class="brush: js notranslate"><code><span class="token keyword">let</span> worldRefSpace<span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">runXR</span><span class="token punctuation">(</span><span class="token parameter">xrSession</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  worldRefSpace <span class="token operator">=</span> <span class="token keyword">await</span> xrSession<span class="token punctuation">.</span><span class="token function">requestReferenceSpace</span><span class="token punctuation">(</span><span class="token string">"local"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>worldRefSpace<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    viewerRefSpace <span class="token operator">=</span> worldRefSpace<span class="token punctuation">.</span><span class="token function">getOffsetReferenceSpace</span><span class="token punctuation">(</span>
      <span class="token keyword">new</span> <span class="token class-name">XRRigidTransform</span><span class="token punctuation">(</span>viewerStartPosition<span class="token punctuation">,</span> viewerStartOrientation<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    animationFrameRequestID <span class="token operator">=</span> xrSession<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>myDrawFrame<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>After getting a reference space for the immersive world, this creates an offset reference space representing the position and orientation of the viewer by creating an <a href="/en-US/docs/Web/API/XRRigidTransform"><code>XRRigidTransform</code></a> representing that position and orientation, then calling the <a href="/en-US/docs/Web/API/XRReferenceSpace"><code>XRReferenceSpace</code></a> method <a href="/en-US/docs/Web/API/XRReferenceSpace/getOffsetReferenceSpace" title="getOffsetReferenceSpace()"><code>getOffsetReferenceSpace()</code></a>.</p>
<p>Then the first animation frame is scheduled by calling the <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> method <a href="/en-US/docs/Web/API/XRSession/requestAnimationFrame" title="requestAnimationFrame()"><code>requestAnimationFrame()</code></a>, providing a callback function, <code>myDrawFrame()</code>, whose job is to render the frame.</p>
<p>Note that this code doesn't have a loop! Instead, the frame rendering code—in this case, a function named <code>myDrawFrame()</code>—is responsible for scheduling time to draw another frame by once again calling <code>requestAnimationFrame()</code>.</p></div></section><section aria-labelledby="refresh_rate_and_frame_rate"><h2 id="refresh_rate_and_frame_rate"><a href="#refresh_rate_and_frame_rate">Refresh rate and frame rate</a></h2><div class="section-content"><p>Assuming you've called the <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> method <a href="/en-US/docs/Web/API/XRSession/requestAnimationFrame" title="requestAnimationFrame()"><code>requestAnimationFrame()</code></a> since the last time the screen refreshed, the browser will call your frame rendering callback every time it's ready to repaint your app or site window. In this context, "repaint" means the process of ensuring that the screen's displayed content matches what the DOM and the elements within are trying to present at the moment.</p></div></section><section aria-labelledby="hardware_vertical_refresh_rate"><h3 id="hardware_vertical_refresh_rate"><a href="#hardware_vertical_refresh_rate">Hardware vertical refresh rate</a></h3><div class="section-content"><p>When the browser is ready to refresh the <a href="/en-US/docs/Web/HTML/Element/canvas"><code>&lt;canvas&gt;</code></a> within which your WebXR content is displayed, it calls your frame rendering callback, which uses the specified timestamp and any other relevant data, such as models and textures, as well as application state, to render the scene—as it should appear at the specified time—into the WebGL backbuffer. When your callback returns, the browser transfers that backbuffer to the display or XR device, along with anything else that's changed since the last time the screen was refreshed.</p>
<p>Historically, displays have refreshed 60 times per second. This is due to early displays using the AC electrical grid's current flow waveform, which cycles 60 times per second in the United States (50 in Europe), for timing purposes. This figure goes by a number of different names, but they're all equivalent or nearly so:</p>
<ul>
  <li>Refresh rate</li>
  <li>Vertical refresh rate</li>
  <li>Vertical blanking rate (VBL)</li>
  <li>Vertical sync rate</li>
</ul>
<p>There are other similar terms used as well, but regardless of what it's called, the unit of measurement applied is the Hertz, or Hz. A display that refreshes 60 times per second has a 60 Hz refresh rate. That means that the maximum number of frames it can display in a second is 60. No matter how many frames per second you render beyond that, only 60 of them will make it to the screen in the course of a second.</p>
<p>But not all displays run at 60 Hz; nowadays, higher performance displays are beginning to use much higher refresh rates. 120 Hz—or 120 frame per second—displays are increasingly common, for example. The browser always tries to refresh at the same rate as the display, which means that on some computers, your callback will be run a maximum of 60 times per second, while on others it might be called 90 or 120 times per second or even more, depending on the frame rate.</p></div></section><section aria-labelledby="time_available_to_render_each_frame"><h3 id="time_available_to_render_each_frame"><a href="#time_available_to_render_each_frame">Time available to render each frame</a></h3><div class="section-content"><p>This makes using the most of the time available between frames critical. If the user's device is using a 60 Hz display, your callback will be called up to 60 times per second, and your goal is to do what you can to ensure that it doesn't get called less often than that. You achieve this by doing as much as is practicable off the main thread and by keeping your frame rendering callback as efficient as possible. The division of time into 60 Hz blocks with each block being used at least in part to render the scene is shown in the diagram below.</p>
<p>
  <img src="/en-US/docs/Web/API/WebXR_Device_API/Rendering/frames-and-refresh-rate.svg" alt="Renderer execution time per frame period" width="881" height="179" loading="lazy">
</p>
<p>This is important because as the computer becomes increasingly busy, it may not be able to accurately call your callback every frame and may have to skip frames. This is called <strong>dropping frames</strong>. This happens when the amount of time it takes to render a frame exceeds the time available between frames, whether because rendering was delayed or because rendering itself took more time than was available.</p>
<p>
  <img src="/en-US/docs/Web/API/WebXR_Device_API/Rendering/dropped-frames-timing.svg" alt="Renderer execution time per frame period" width="881" height="198" loading="lazy">
</p>
<p>In the diagram above, frame 3 is dropped because frame 2 did not complete rendering until after frame 3 was due to be painted. The next frame drawn will be frame 4 instead. This is another reason the timestamp passed into your rendering callback is useful. By configuring the scene based on time rather than frame number, you can ensure your rendered frames match what's expected instead of falling behind.</p>
<p>When a frame is dropped, the contents of the affected display area don't change for that pass through the frame loop. For that reason, the occasional dropped frame isn't usually particularly noticeable, but if it starts to happen a lot—especially if several frames are dropped in a very short span of time—it can become jarring or even leave your display unusable.</p>
<p>Fortunately, you can easily compute how much time you're allowed to use between frames as <code>1/refreshRate</code> seconds. That is, by dividing 1 by the display's refresh rate. The resulting value is the amount of time available for each frame to be rendered in order to not drop the frame. For example, a 60 Hz display has 1/60th of a second to render a single frame, or 0.0166667 seconds. And if the device's refresh rate is 120 Hz, you only have 0.00883333 seconds to render each frame if you want to avoid dropping frames.</p>
<p>Even if the hardware is actually 120 Hz, though, you can get by with just refreshing 60 times per second anyway, and targeting that is usually a good baseline to follow. 60 FPS is already beyond the point at which most people can easily detect that the animation isn't a series of still images going by really fast. In other words, when in doubt, you can assume that the display is refreshing at 60 Hz. As long as your code is written properly, everything will be fine.</p></div></section><section aria-labelledby="renderer_performance_concerns"><h3 id="renderer_performance_concerns"><a href="#renderer_performance_concerns">Renderer performance concerns</a></h3><div class="section-content"><p>Clearly, you have very little time to render your scene each frame. Not only that, but if your renderer itself runs longer than that amount of time, you can cause not just the frame to get dropped, but that time to be wasted entirely, blocking other code from getting to run at all for that frame.</p>
<p>Not only that, but if your rendering crosses the vertical refresh boundary, you can wind up with a <strong>tearing</strong> effect. Tearing occurs when the display hardware starts the next refresh cycle while the previous frame is still being drawn to the screen. As a result, you wind up with the visual effect of the top part of the screen showing the new frame, while the bottom part of the frame shows some combination of the previous frame and possibly even the frame before that one.</p>
<p>Your mission, then, is to keep your code tight and lightweight enough that you don't overrun the time available to you or otherwise cause dropped frames or excessively abuse the main thread.</p>
<p>For these reasons, unless your renderer is fairly small and lightweight, with little to do, you should consider offloading everything you can to a worker so you can be computing the next frame while the browser handles other things. By having your computations and data ready before the frame is actually called for, you can make your site or app render much more efficiently, improving main thread performance and generally making the user experience better.</p>
<p>Fortunately, there are some tricks you can use to further reduce your impact and optimize performance if your rendering needs are particularly heavy. See the <a href="/en-US/docs/Web/API/WebXR_Device_API/Performance">WebXR performance guide</a> for recommendations and tips that will help you ensure your performance is as good as it can be.</p></div></section><section aria-labelledby="webxr_frames"><h2 id="webxr_frames"><a href="#webxr_frames">WebXR frames</a></h2><div class="section-content"><p>Your frame rendering callback function receives as input two parameters: the time to which the frame corresponds, and an <a href="/en-US/docs/Web/API/XRFrame"><code>XRFrame</code></a> object describing the state of the scene as of that time.</p></div></section><section aria-labelledby="the_optics_of_3d"><h3 id="the_optics_of_3d"><a href="#the_optics_of_3d">The optics of 3D</a></h3><div class="section-content"><p>We have two eyes for a reason: by having two eyes, each inherently sees the world from a slightly different angle. Since they're a known, fixed distance apart, our brains can do basic geometry and trigonometry and figure out the 3D nature of reality from that information. We also make use of perspective, size differences, and even our understanding of how things usually look to figure out the details of that third dimension. These factors, among others, are the source of our <a href="https://en.wikipedia.org/wiki/Depth_perception" class="external" target="_blank">depth perception</a>.</p>
<p>To create the illusion of three dimensions when rendering graphics, we need to simulate as many of these factors as we can. The more of these we simulate—and the more accurately we do so—the better we are able to trick the human brain into perceiving our images in 3D. The advantage to XR is that not only can we use the classic monocular techniques to simulate 3D graphics (perspective, size, and simulated parallax), but we can also simulate binocular vision—that is, vision using two eyes—by rendering the scene twice for each frame of animation—once for each eye.</p>
<p>The typical human's <a href="https://en.wikipedia.org/wiki/Pupillary_distance" class="external" target="_blank">pupillary distance</a>—the distance between the centers of the pupils—is between 54 and 74 millimeters (0.054 to 0.074 meters). So if the center of the viewer's head is located at <code>[0.0, 2.0, 0.0]</code> (about two meters above ground level at the center of the space horizontally), we first need to render the scene from, say, <code>[-0.032, 2.0, 0.0]</code> (32mm to the left of center) and then render it again at <code>[0.032, 2.0, 0.0]</code> (32mm right of center.) This way, we place the positions of the viewer's eyes at an average human pupillary distance of 64mm.</p>
<p>That distance (or whatever pupillary distance the XR system is configured to use) is enough to allow our minds to see just enough difference due to retinal disparity (the difference in what each retina sees) and the parallax effect to allow our brains to calculate the distance to and depth of objects, thus enabling us to perceive three dimensions despite our retinas only being 2D surfaces.</p>
<p>This is illustrated in the diagram below, in which we see how each eye perceives a die located directly in front of the viewer. While this diagram exaggerates the effect in some respects for illustrative purposes, the concept is the same. Each eye sees an area whose boundaries make up an arc in front of the eye. Because each eye is offset to one side or the other of the head's centerline, and each eye sees about the same field of view, the result is that each eye sees a slightly different part of the world in front of it, and from a slightly different angle.</p>
<p>
  <img src="/en-US/docs/Web/API/WebXR_Device_API/Rendering/binocular-vision.svg" alt="Diagram showing how binocular vision works" width="550" height="720" loading="lazy">
</p>
<p>The left eye sees the die from a little bit to the left of center, and the right eye sees it from a bit to the right of center. As a result, the left eye sees just a little bit more of the left side of the object and a little bit less of the right, and vice versa. These two images are focused onto the retinas and the resulting signal transmitted over the optic nerves to the brain's visual cortex, located at the back of the occipital lobe.</p>
<p>The brain takes those signals from the left and right eyes and constructs a single, unified, 3D image of the world in the viewer's brain, and that image is what is seen. And because of those differences between what is seen by the left eye versus the right eye, the brain is able to infer a great deal of information about how deep the object is, its size, and more. By combining that inferred depth information with other cues such as perspective, shadows, memories of what these relationships mean, and so forth, we can figure out a great deal about the world around us.</p></div></section><section aria-labelledby="frames_poses_views_and_framebuffers"><h3 id="frames_poses_views_and_framebuffers"><a href="#frames_poses_views_and_framebuffers">Frames, poses, views, and framebuffers</a></h3><div class="section-content"><p>Once you have an <code>XRFrame</code> representing the state of the scene at a moment in time, you need to determine the positions of objects within the scene relative to the viewer so that you can render them. The viewer's position and orientation relative to a reference space is represented by an <a href="/en-US/docs/Web/API/XRViewerPose"><code>XRViewerPose</code></a> obtained by calling the <a href="/en-US/docs/Web/API/XRFrame"><code>XRFrame</code></a> method <a href="/en-US/docs/Web/API/XRFrame/getViewerPose" title="getViewerPose()"><code>getViewerPose()</code></a>.</p>
<p>The <code>XRFrame</code> doesn't directly keep track of the positions or orientations of the objects in your world. Instead, it offers a way to convert positions and orientations into the scene's coordinate system, and it collects the viewer's position and orientation data from the XR hardware, converts it into the reference space you've configured, and delivers it to your frame rendering code with a timestamp. You use that timestamp and your own data to determine how to render the scene.</p>
<p>After rendering the scene twice—once into the left half of the framebuffer and once into the right half of the framebuffer—the framebuffer is sent to the XR hardware, which displays each half of the framebuffer to the corresponding eye. This is often (but not always) done by drawing the image to a single screen and using lenses to transfer the correct half of that image to each eye.</p>
<p>You can learn more about how 3D is represented by WebXR in <a href="/en-US/docs/Web/API/WebXR_Device_API/Cameras#representing_3d_with_webxr">Representing 3D with WebXR</a>.</p></div></section><section aria-labelledby="drawing_the_scene"><h2 id="drawing_the_scene"><a href="#drawing_the_scene">Drawing the scene</a></h2><div class="section-content"><p>When the time comes to prepare the framebuffer so the browser can paint the next frame of your scene, the function you provided to <code>requestAnimationFrame()</code> is invoked. It receives as input the time at which the frame being drawn and an <a href="/en-US/docs/Web/API/XRFrame"><code>XRFrame</code></a> object providing details about the state of the scene for the frame you need to render.</p>
<p>Ideally, you want this code to be fast enough that it can maintain a 60 FPS frame rate, or as close to that as possible, remembering that there's more going on than just your code in this one function. You need to make sure that the main thread doesn't need to run for more time per frame than the duration of the frame itself.</p></div></section><section aria-labelledby="a_basic_renderer"><h3 id="a_basic_renderer"><a href="#a_basic_renderer">A basic renderer</a></h3><div class="section-content"><p>In this version of the WebXR rendering callback, we use a very straightforward approach that works great for relatively simple projects. This pseudocode outlines that process:</p>
<pre class="brush: plain notranslate">for each view in the pose's views list:
  get the WebXR GL layer's viewport
  set the WebGL viewport to match
  for each object in the scene
    bindProgram()
    bindVertices()
    bindMatrices()
    bindUniforms()
    bindBuffers()
    bindTextures()
    drawMyObject()
</pre>
<p>Put, this form of renderer is using <strong>view-first order</strong>. Each of the two views making up the XR device's display are rendered back to back, where every object is drawn on one view before rendering the same set of objects on the other view. As a result, there's a good bit of replicated effort, since much of the data needed to draw an object winds up getting sent to the GPU twice per frame. However, it simplifies porting existing WebGL code and is frequently good enough to do the job, so we'll look at this method first.</p>
<p>See <a href="#optimizing_by_rendering_in_object-first_order">Optimizing by rendering in object-first order</a> for an alternative approach that renders each object twice back-to-back, once for each eye, before moving on to the next object that makes up the scene for that frame; that is, rendering in <strong>object-first order</strong>.</p>
<h4 id="sample_rendering_callback">Sample rendering callback</h4>
<p>Let's take a look at some real code that follows this basic pattern. Since in the example above we gave this function the name <code>myDrawFrame()</code>, we'll continue to use that here.</p>
<div class="code-example"><p class="example-header"><span class="language-name">js</span></p><pre class="brush: js notranslate"><code><span class="token keyword">let</span> lastFrameTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">myDrawFrame</span><span class="token punctuation">(</span><span class="token parameter">currentFrameTime<span class="token punctuation">,</span> frame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> session <span class="token operator">=</span> frame<span class="token punctuation">.</span>session<span class="token punctuation">;</span>
  <span class="token keyword">let</span> viewerPose<span class="token punctuation">;</span>

  <span class="token comment">// Schedule the next frame to be painted when the time comes.</span>

  animationFrameRequestID <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>myDrawFrame<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Get an XRViewerPose representing the position and</span>
  <span class="token comment">// orientation of the viewer. If successful, render the</span>
  <span class="token comment">// frame.</span>

  viewerPose <span class="token operator">=</span> frame<span class="token punctuation">.</span><span class="token function">getViewerPose</span><span class="token punctuation">(</span>viewerRefSpace<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>viewerPose<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> glLayer <span class="token operator">=</span> session<span class="token punctuation">.</span>renderState<span class="token punctuation">.</span>baseLayer<span class="token punctuation">;</span>
    gl<span class="token punctuation">.</span><span class="token function">bindFrameBuffer</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span><span class="token constant">FRAMEBUFFER</span><span class="token punctuation">,</span> glLayer<span class="token punctuation">.</span>framebuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Start by erasing the color and depth framebuffers.</span>

    gl<span class="token punctuation">.</span><span class="token function">clearColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gl<span class="token punctuation">.</span><span class="token function">clearDepth</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gl<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span><span class="token constant">COLOR_BUFFER_BIT</span> <span class="token operator">|</span> gl<span class="token punctuation">.</span><span class="token constant">DEPTH_BUFFER_BIT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Compute the time elapsed since the last frame was rendered.</span>
    <span class="token comment">// Use this value to ensure your animation runs at the exact</span>
    <span class="token comment">// rate you intend.</span>

    <span class="token keyword">const</span> deltaTime <span class="token operator">=</span> currentFrameTime <span class="token operator">-</span> lastFrameTime<span class="token punctuation">;</span>
    lastFrameTime <span class="token operator">=</span> currentFrameTime<span class="token punctuation">;</span>

    <span class="token comment">// Now call the scene rendering code once for each of</span>
    <span class="token comment">// the session's views.</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> view <span class="token keyword">of</span> viewerPose<span class="token punctuation">.</span>views<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> viewport <span class="token operator">=</span> glLayer<span class="token punctuation">.</span><span class="token function">getViewport</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span>
      gl<span class="token punctuation">.</span><span class="token function">viewport</span><span class="token punctuation">(</span>viewport<span class="token punctuation">.</span>x<span class="token punctuation">,</span> viewport<span class="token punctuation">.</span>y<span class="token punctuation">,</span> viewport<span class="token punctuation">.</span>width<span class="token punctuation">,</span> viewport<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">myDrawSceneIntoView</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> deltaTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>The <code>myDrawFrame()</code> function grabs the <a href="/en-US/docs/Web/API/XRSession"><code>XRSession</code></a> from the <a href="/en-US/docs/Web/API/XRFrame"><code>XRFrame</code></a> object specified by the <code>frame</code> parameter, then calls the session's <a href="/en-US/docs/Web/API/XRSession/requestAnimationFrame" title="requestAnimationFrame()"><code>requestAnimationFrame()</code></a> method to immediately schedule the rendering of the next frame. This ensures we get into the queue right away, allowing the rest of the time spent in this iteration of the <code>myDrawFrame()</code> function to count toward the timing of drawing the next frame.</p>
<p>We then get the <a href="/en-US/docs/Web/API/XRViewerPose"><code>XRViewerPose</code></a> object that describes the viewer's pose—their position and orientation—using the frame's <a href="/en-US/docs/Web/API/XRFrame/getViewerPose" title="getViewerPose()"><code>getViewerPose()</code></a> method, passing in the viewer's reference space from the <code>viewerRefSpace</code> previously obtained <a href="#preparing_the_renderer">while setting up the WebXR session</a>.</p>
<p>With the viewer's pose in hand, we can then begin to render the frame. The first step is to obtain access to the framebuffer into which the WebXR device wants the frame drawn; this is done by getting the target WebGL layer from the session's <a href="/en-US/docs/Web/API/XRSession/renderState" title="renderState"><code>renderState</code></a> object's <a href="/en-US/docs/Web/API/XRRenderState/baseLayer" title="baseLayer"><code>baseLayer</code></a> property, then getting the <a href="/en-US/docs/Web/API/XRWebGLLayer/framebuffer" title="framebuffer"><code>framebuffer</code></a> from that <a href="/en-US/docs/Web/API/XRWebGLLayer"><code>XRWebGLLayer</code></a> object. We then call <a href="/en-US/docs/Web/API/WebGLRenderingContext/bindFramebuffer"><code>gl.bindFrameBuffer()</code></a> to bind that framebuffer as the target for all upcoming drawing commands.</p>
<p>The next step is to erase the framebuffer. While you can in theory skip this step—<em>if and only if your rendering code is guaranteed to write every single pixel in the framebuffer</em>—it's generally safest to just go ahead and clear it before you begin to draw, unless you need to eke out every ounce of performance you can and know you're touching all the pixels anyway. The background color is set to fully opaque black using <a href="/en-US/docs/Web/API/WebGLRenderingContext/clearColor"><code>gl.clearColor()</code></a>; the clear depth is set to 1.0 by calling <a href="/en-US/docs/Web/API/WebGLRenderingContext/clearDepth"><code>gl.cleardepth()</code></a>, in order to clear all pixels regardless of how far away the object they're part of is; and finally, the frame's pixel and depth buffers are both erased by calling <a href="/en-US/docs/Web/API/WebGLRenderingContext/clear"><code>gl.clear()</code></a>, passing in a bit mask in which both <code>COLOR_BUFFER_BIT</code> and <code>DEPTH_BUFFER_BIT</code> are set.</p>
<p>Since WebXR uses a single framebuffer for every view, with viewports upon the view being used to separate each eye's viewpoint within the framebuffer, we only need to clear a single framebuffer rather than cleaning it for each eye (or other viewpoints, if any) individually.</p>
<p>Next, the time elapsed since the previous frame was rendered is calculated by subtracting from the current time as specified by the <code>currentFrameTime</code> parameter the saved time at which the last frame was rendered, <code>lastFrameTime</code>. The result is a <a href="/en-US/docs/Web/API/DOMHighResTimeStamp"><code>DOMHighResTimeStamp</code></a> value indicating the number of milliseconds that have elapsed since the last frame was rendered. We can use this value while drawing the scene to ensure we move everything the appropriate distance given the true elapsed time, rather than assuming that the callback will be fired at a consistent frame rate. This elapsed time is saved in the variable <code>deltaTime</code>, and the value of <code>lastFrameTime</code> is replaced with this frame's time, ready to compute the differential for the next frame.</p>
<p>It's now time to actually render the scene for each eye. We iterate over the views within the viewer poses's <a href="/en-US/docs/Web/API/XRViewerPose/views" title="views"><code>views</code></a> array. For each of these <a href="/en-US/docs/Web/API/XRView"><code>XRView</code></a> objects representing an eye's perspective on the scene, we need to begin by limiting drawing to the area of the framebuffer which represents the current eye's visible image.</p>
<p>We begin by preparing WebGL to render the eye's contents by getting the viewport that restricts drawing to the area within the framebuffer that's reserved for the current eye's image by calling the <a href="/en-US/docs/Web/API/XRWebGLLayer"><code>XRWebGLLayer</code></a> method <a href="/en-US/docs/Web/API/XRWebGLLayer/getViewport" title="getViewport()"><code>getViewport()</code></a>. We then set the WebGL viewport to match, passing in the X and Y origin of the viewport along with its width and height into <a href="/en-US/docs/Web/API/WebGLRenderingContext/viewport"><code>gl.viewport()</code></a>.</p>
<p>Finally, we call our method <code>myDrawSceneIntoView()</code> to actually use WebGL to render the scene. Into this, we pass the <a href="/en-US/docs/Web/API/XRView"><code>XRView</code></a> representing the eye we're drawing for (in order to perform perspective mapping and the like) and <code>deltaTime</code>, so the scene drawing code can accurately represent the elapsed time when determining the positions of objects moving over time.</p>
<p>When the loop that's iterating over the views ends, every image required to represent the scene to the viewer has been rendered, and upon return, the framebuffer makes its way through the GPU and eventually to the XR device's display or displays. Since we called <a href="/en-US/docs/Web/API/XRSession/requestAnimationFrame" title="requestAnimationFrame()"><code>requestAnimationFrame()</code></a> at the top of the function, our callback will be invoked once again when it's time to render the next frame of the scene's animation.</p>
<h4 id="drawbacks_to_this_approach">Drawbacks to this approach</h4>
<p>Since it's important to minimize how much time you spend in this function as much as possible, the more time you spend handling state changes, the less time you have to actually draw things. This technique works very well for a small number of objects, but because it has to re-bind all the data for each object twice (once for the left eye, and once for the right), you're spending a lot of time adjusting the state, uploading buffers and textures, and so forth. In the next section, we look at an altered approach that reduces these state changes substantially, providing a potentially much faster rendering approach, especially as your object count goes up.</p></div></section><section aria-labelledby="optimizing_by_rendering_in_object-first_order"><h3 id="optimizing_by_rendering_in_object-first_order"><a href="#optimizing_by_rendering_in_object-first_order">Optimizing by rendering in object-first order</a></h3><div class="section-content"><p>An advantage of WebXR's approach of using a single WebGL framebuffer to contain both the left and right eye's views in a single framebuffer makes it possible to substantially improve rendering performance by rearranging the order in which things are done. Instead of setting up the viewport for a given view (such as the left eye), then rendering every object visible to the left eye, one by one, reconfiguring buffers for each object as you go, you can instead render each object twice in a row, once for each eye, thereby only needing to set up the buffers, uniforms, and so forth once for both eyes.</p>
<p>The resulting pseudocode looks like this:</p>
<pre class="brush: plain notranslate">for each object in the scene
  bindProgram()
  bindUniforms()
  bindBuffers()
  bindTextures()
  for each view in the pose's views list
    get the XRWebGLLayer's viewport
    set the WebGL viewport to match
    bindVertices()
    bindMatrices()
    drawMyObject()
</pre>
<p>By changing things up in this way, we only bind programs, uniforms, buffers, textures, and potentially other things once per frame instead of twice for each object found in the scene. This reduces overhead by a potentially very large margin.</p></div></section><section aria-labelledby="limiting_the_frame_rate"><h3 id="limiting_the_frame_rate"><a href="#limiting_the_frame_rate">Limiting the frame rate</a></h3><div class="section-content"><p>If you need to intentionally cap your frame rate in order to establish a baseline frame rate to try to maintain while allowing more time for other code to run, you can do so by skipping frames intentionally, on a timed basis.</p>
<p>For example, to reduce the frame rate by 50%, just skip every other frame:</p>
<div class="code-example"><p class="example-header"><span class="language-name">js</span></p><pre class="brush: js notranslate"><code><span class="token keyword">let</span> tick <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token parameter">time<span class="token punctuation">,</span> frame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  animationFrameRequestID <span class="token operator">=</span> frame<span class="token punctuation">.</span>session<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>drawFrame<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>tick <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Draw the scene */</span>
  <span class="token punctuation">}</span>
  tick<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>This version of the rendering callback maintains a <code>tick</code> counter. The frame is only rendered if <code>tick</code> is an even number value. This way, only every other frame gets rendered.</p>
<p>You can similarly render every fourth frame using <code>!(tick % 4)</code>, and so forth.</p></div></section><section aria-labelledby="matching_your_animation_to_the_elapsed_time"><h3 id="matching_your_animation_to_the_elapsed_time"><a href="#matching_your_animation_to_the_elapsed_time">Matching your animation to the elapsed time</a></h3><div class="section-content"><p>The rendering callback receives a <code>time</code> parameter for a good reason. This <a href="/en-US/docs/Web/API/DOMHighResTimeStamp"><code>DOMHighResTimeStamp</code></a> value is a floating-point value indicating the time at which the frame was scheduled for rendering. Because the execution of your callback is not going to happen at precise 1/60th of a second intervals—and, indeed, could happen at other rates if the user's display has a different frame rate—you can't rely on the simple fact that your code is running to assume that it's been 1/60th of a second since the last frame.</p>
<p>For that reason, you need to use the timestamp provided to ensure your animation renders at precisely the desired speed. To do so, the first thing you need to do is to compute the time that has elapsed since the last frame was rendered:</p>
<div class="code-example"><p class="example-header"><span class="language-name">js</span></p><pre class="brush: js notranslate"><code><span class="token keyword">let</span> lastFrameTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token parameter">time<span class="token punctuation">,</span> frame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// schedule next frame, prepare the buffer, etc.</span>

  <span class="token keyword">const</span> deltaTime <span class="token operator">=</span> <span class="token punctuation">(</span>time <span class="token operator">-</span> lastFrameTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.001</span><span class="token punctuation">;</span>
  lastFrameTime <span class="token operator">=</span> time<span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> view <span class="token keyword">of</span> pose<span class="token punctuation">.</span>views<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* render each view */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>This maintains a global (or an object property) called <code>lastFrameTime</code> which contains the previous frame's time of rendering. In this case, since the time values are stored in milliseconds, we multiply by 0.001 to convert the time into seconds. In some cases, this saves time later. In other situations, you need the time in milliseconds, so you wouldn't need to change anything.</p>
<p>With the elapsed time in hand, your rendering code has the means to compute just how much every moving object has moved in the time elapsed. For instance, if an object is rotating, you might apply the rotation like this:</p>
<div class="code-example"><p class="example-header"><span class="language-name">js</span></p><pre class="brush: js notranslate"><code><span class="token keyword">const</span> xDeltaRotation <span class="token operator">=</span>
  xRotationDegreesPerSecond <span class="token operator">*</span> <span class="token constant">RADIANS_PER_DEGREE</span> <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span>
<span class="token keyword">const</span> yDeltaRotation <span class="token operator">=</span>
  yRotationDegreesPerSecond <span class="token operator">*</span> <span class="token constant">RADIANS_PER_DEGREE</span> <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span>
<span class="token keyword">const</span> zDeltaRotation <span class="token operator">=</span>
  zRotationDegreesPerSecond <span class="token operator">*</span> <span class="token constant">RADIANS_PER_DEGREE</span> <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span>
</code></pre></div>
<p>This computes the amount by which the object has rotated around each of the three axes since the last time the frame was drawn. Without this, the shape would rotate by the given amount every frame, regardless of the elapsed time. This could cause substantial stutter in many cases.</p>
<p>The same concept applied for objects that are moving rather than rotating:</p>
<div class="code-example"><p class="example-header"><span class="language-name">js</span></p><pre class="brush: js notranslate"><code><span class="token keyword">const</span> xDistanceMoved <span class="token operator">=</span> xSpeedPerSecond <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span>
<span class="token keyword">const</span> yDistanceMoved <span class="token operator">=</span> ySpeedPerSecond <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span>
<span class="token keyword">const</span> ZDistanceMoved <span class="token operator">=</span> zSpeedPerSecond <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span>
</code></pre></div>
<p><code>xSpeedPerSecond</code>, <code>ySpeedPerSecond</code>, and <code>zSpeedPerSecond</code> each contain that axis's component of the object's velocity. In other words, <code>[xDistanceMoved, yDistanceMoved, zDistanceMoved]</code> is a vector representing the velocity of the object.</p></div></section><section aria-labelledby="additional_tasks_related_to_animating_the_scene"><h2 id="additional_tasks_related_to_animating_the_scene"><a href="#additional_tasks_related_to_animating_the_scene">Additional tasks related to animating the scene</a></h2><div class="section-content"><p>There are, of course, other things that probably need to happen each pass through the renderer. Two of the most common are <a href="/en-US/docs/Web/API/WebXR_Device_API/Inputs">handling of user inputs</a> and performing updates to the positions of objects (or the viewer) based on known factors, such as those user control states or known animation paths of the objects in the scene.</p></div></section><section aria-labelledby="handling_user_control_inputs"><h3 id="handling_user_control_inputs"><a href="#handling_user_control_inputs">Handling user control inputs</a></h3><div class="section-content"><p>There are three methods by which users might provide input while using a WebXR application. First, WebXR supports directly handling inputs from the controllers which are integrated with the XR hardware itself. These input sources may include devices such as hand controllers, optical tracking systems, accelerometers and magnetometers, and other devices of that nature.</p>
<p>The second type of input is a gamepad that's connected through the XR system. This uses interfaces inherited from the <a href="/en-US/docs/Web/API/Gamepad_API">Gamepad API</a> but you interact with them through WebXR.</p>
<p>The third and final type of input is the traditional non-XR input device such as keyboards, mice, trackpads, touch screens, and non-XR gamepads and joysticks.</p>
<p>Orientation and position information that can be collected from the XR hardware directly is applied automatically. Thus it's the other kinds of input that you need to handle yourself:</p>
<ul>
  <li>Pointing device target and button presses</li>
  <li>Gamepad inputs</li>
  <li>Non-XR input device inputs</li>
</ul>
<p>To learn more about how to handle user inputs while presenting a scene using WebXR, see the article <a href="/en-US/docs/Web/API/WebXR_Device_API/Inputs">Inputs and input sources</a>.</p></div></section><section aria-labelledby="updating_object_positions"><h3 id="updating_object_positions"><a href="#updating_object_positions">Updating object positions</a></h3><div class="section-content"><p>Most (though not all) scenes include some form of animation, in which things move and react to one another in appropriate ways.</p>
<p>For example, a virtual reality or augmented reality game might have enemy non-player characters being controlled by the computer and moving around the scene. Not only are their locations in the world changing over time, but each NPC likely has body parts or components that are moving in relation to one another. Arms and legs swing as a creature walks, heads bob and turn, hair bounces and sways, torsos expand and contract as the character breathes.</p>
<p>In addition, there may be objects and structures in motion. In a sports game, there may be a ball arcing through the air, its movement needing to be simulated. In racing games there may be cars or other vehicles, with moving parts to animate including the wheels. If there's water in the scene, it needs ripples or waves to look realistic. Parts of structures may be moving, such as doors, walls and floors (for some types of games), and so forth.</p>
<p>Another common source of motion is the player themselves. After interpreting inputs from the controls (both XR-affiliated and otherwise), you need to apply those changes to the scene in order to simulate the user's movement. See the article <a href="/en-US/docs/Web/API/WebXR_Device_API/Movement_and_motion">Movement, orientation, and motion</a> for details and a thorough example of how this works.</p></div></section><section aria-labelledby="next_steps"><h2 id="next_steps"><a href="#next_steps">Next steps</a></h2><div class="section-content"><p>Once you've got your renderer written—or at least got something that works, even if it's not finished—you can begin to deal with the camera and its movement through the scene. This is covered in our article about <a href="/en-US/docs/Web/API/WebXR_Device_API/Cameras">viewpoints and viewers</a> in WebXR.</p></div></section><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
  <li><a href="/en-US/docs/Web/API/WebXR_Device_API/Geometry">Geometry and reference spaces in WebXR</a></li>
  <li><a href="/en-US/docs/Web/API/WebXR_Device_API/Spatial_tracking">Spatial tracking in WebXR</a></li>
  <li><a href="/en-US/docs/Web/API/WebXR_Device_API/Cameras">Viewpoints and viewers: Simulating cameras in WebXR</a></li>
  <li><a href="/en-US/docs/Web/API/WebXR_Device_API/Movement_and_motion">Movement, orientation, and motion: A WebXR example</a></li>
  <li><a href="/en-US/docs/Web/API/WebXR_Device_API/Performance">WebXR performance guide</a></li>
</ul></div></section><aside class="metadata"><div class="metadata-content-container"><div id="on-github" class="on-github"><h3>Found a content problem with this page?</h3><ul><li><a href="https://github.com/mdn/content/edit/main/files/en-us/web/api/webxr_device_api/rendering/index.md" title="This will take you to GitHub, where you&#x27;ll need to sign in first." target="_blank" rel="noopener noreferrer">Edit the page on GitHub</a>.</li><li><a href="https://github.com/mdn/content/issues/new?template=page-report.yml&amp;mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebXR_Device_API%2FRendering&amp;metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fapi%2Fwebxr_device_api%2Frendering%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebXR_Device_API%2FRendering%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fapi%2Fwebxr_device_api%2Frendering%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F592f6ec42e54981b6573b58ec0343c9aa8cbbda8%0A*+Document+last+modified%3A+2023-07-25T00%3A27%3A48.000Z%0A%0A%3C%2Fdetails%3E" title="This will take you to GitHub to file a new issue." target="_blank" rel="noopener noreferrer">Report the content issue</a>.</li><li><a href="https://github.com/mdn/content/blob/main/files/en-us/web/api/webxr_device_api/rendering/index.md?plain=1" title="Folder: en-us/web/api/webxr_device_api/rendering (Opens in a new tab)" target="_blank" rel="noopener noreferrer">View the source on GitHub</a>.</li></ul>Want to get more involved?<!-- --> <a href="https://github.com/mdn/content/blob/main/CONTRIBUTING.md" title="This will take you to our contribution guidelines on GitHub." target="_blank" rel="noopener noreferrer">Learn how to contribute</a>.</div><p class="last-modified-date">This page was last modified on<!-- --> <time dateTime="2023-07-25T00:27:48.000Z">Jul 25, 2023</time> by<!-- --> <a href="/en-US/docs/Web/API/WebXR_Device_API/Rendering/contributors.txt">MDN contributors</a>.</p></div></aside></article></main></div></div><footer id="nav-footer" class="page-footer"><div class="page-footer-grid"><div class="page-footer-logo-col"><a href="/" class="mdn-footer-logo" aria-label="MDN homepage"><svg width="48" height="17" viewBox="0 0 48 17" fill="none" xmlns="http://www.w3.org/2000/svg"><title id="mdn-footer-logo-svg">MDN logo</title><path d="M20.04 16.512H15.504V10.416C15.504 9.488 15.344 8.824 15.024 8.424C14.72 8.024 14.264 7.824 13.656 7.824C12.92 7.824 12.384 8.064 12.048 8.544C11.728 9.024 11.568 9.64 11.568 10.392V14.184H13.008V16.512H8.472V10.416C8.472 9.488 8.312 8.824 7.992 8.424C7.688 8.024 7.232 7.824 6.624 7.824C5.872 7.824 5.336 8.064 5.016 8.544C4.696 9.024 4.536 9.64 4.536 10.392V14.184H6.6V16.512H0V14.184H1.44V8.04H0.024V5.688H4.536V7.32C5.224 6.088 6.32 5.472 7.824 5.472C8.608 5.472 9.328 5.664 9.984 6.048C10.64 6.432 11.096 7.016 11.352 7.8C11.992 6.248 13.168 5.472 14.88 5.472C15.856 5.472 16.72 5.776 17.472 6.384C18.224 6.992 18.6 7.936 18.6 9.216V14.184H20.04V16.512Z" fill="currentColor"></path><path d="M33.6714 16.512H29.1354V14.496C28.8314 15.12 28.3834 15.656 27.7914 16.104C27.1994 16.536 26.4154 16.752 25.4394 16.752C24.0154 16.752 22.8954 16.264 22.0794 15.288C21.2634 14.312 20.8554 12.984 20.8554 11.304C20.8554 9.688 21.2554 8.312 22.0554 7.176C22.8554 6.04 24.0634 5.472 25.6794 5.472C26.5594 5.472 27.2794 5.648 27.8394 6C28.3994 6.352 28.8314 6.8 29.1354 7.344V2.352H26.9754V0H32.2314V14.184H33.6714V16.512ZM29.1354 11.04V10.776C29.1354 9.88 28.8954 9.184 28.4154 8.688C27.9514 8.176 27.3674 7.92 26.6634 7.92C25.9754 7.92 25.3674 8.176 24.8394 8.688C24.3274 9.2 24.0714 10.008 24.0714 11.112C24.0714 12.152 24.3114 12.944 24.7914 13.488C25.2714 14.032 25.8394 14.304 26.4954 14.304C27.3114 14.304 27.9514 13.96 28.4154 13.272C28.8954 12.584 29.1354 11.84 29.1354 11.04Z" fill="currentColor"></path><path d="M47.9589 16.512H41.9829V14.184H43.4229V10.416C43.4229 9.488 43.2629 8.824 42.9429 8.424C42.6389 8.024 42.1829 7.824 41.5749 7.824C40.8389 7.824 40.2709 8.056 39.8709 8.52C39.4709 8.968 39.2629 9.56 39.2469 10.296V14.184H40.6869V16.512H34.7109V14.184H36.1509V8.04H34.5909V5.688H39.2469V7.344C39.9669 6.096 41.1269 5.472 42.7269 5.472C43.7509 5.472 44.6389 5.776 45.3909 6.384C46.1429 6.992 46.5189 7.936 46.5189 9.216V14.184H47.9589V16.512Z" fill="currentColor"></path></svg></a><p>Your blueprint for a better internet.</p><ul class="social-icons"><li><a class="icon icon-mastodon" href="https://mozilla.social/@mdn" target="_blank" rel="me noopener noreferrer"><span class="visually-hidden">MDN on Mastodon</span></a></li><li><a class="icon icon-twitter" href="https://twitter.com/mozdevnet" target="_blank" rel="noopener noreferrer"><span class="visually-hidden">MDN on Twitter</span></a></li><li><a class="icon icon-github-mark-small" href="https://github.com/mdn/" target="_blank" rel="noopener noreferrer"><span class="visually-hidden">MDN on GitHub</span></a></li><li><a class="icon icon-feed" href="/en-US/blog/rss.xml" target="_blank"><span class="visually-hidden">MDN Blog RSS Feed</span></a></li></ul></div><div class="page-footer-nav-col-1"><h2 class="footer-nav-heading">MDN</h2><ul class="footer-nav-list"><li class="footer-nav-item"><a href="/en-US/about">About</a></li><li class="footer-nav-item"><a href="/en-US/blog/">Blog</a></li><li class="footer-nav-item"><a href="https://www.mozilla.org/en-US/careers/listings/?team=ProdOps" target="_blank" rel="noopener noreferrer">Careers</a></li><li class="footer-nav-item"><a href="/en-US/advertising">Advertise with us</a></li></ul></div><div class="page-footer-nav-col-2"><h2 class="footer-nav-heading">Support</h2><ul class="footer-nav-list"><li class="footer-nav-item"><a class="footer-nav-link" href="/en-US/docs/MDN/Community/Issues">Report an issue</a></li></ul></div><div class="page-footer-nav-col-3"><h2 class="footer-nav-heading">Our communities</h2><ul class="footer-nav-list"><li class="footer-nav-item"><a class="footer-nav-link" href="/en-US/community">MDN Community</a></li><li class="footer-nav-item"><a class="footer-nav-link" href="https://discourse.mozilla.org/c/mdn/236" target="_blank" rel="noopener noreferrer">MDN Forum</a></li><li class="footer-nav-item"><a class="footer-nav-link" href="/discord" target="_blank" rel="noopener noreferrer">MDN Chat</a></li></ul></div><div class="page-footer-nav-col-4"><h2 class="footer-nav-heading">Developers</h2><ul class="footer-nav-list"><li class="footer-nav-item"><a class="footer-nav-link" href="/en-US/docs/Web">Web Technologies</a></li><li class="footer-nav-item"><a class="footer-nav-link" href="/en-US/docs/Learn">Learn Web Development</a></li><li class="footer-nav-item"><a href="https://hacks.mozilla.org/" target="_blank" rel="noopener noreferrer">Hacks Blog</a></li></ul></div><div class="page-footer-moz"><a href="https://www.mozilla.org/" class="footer-moz-logo-link" target="_blank" rel="noopener noreferrer"><svg width="112" height="32" fill="none" xmlns="http://www.w3.org/2000/svg"><title id="mozilla-footer-logo-svg">Mozilla logo</title><path d="M41.753 14.218c-2.048 0-3.324 1.522-3.324 4.157 0 2.423 1.119 4.286 3.29 4.286 2.082 0 3.447-1.678 3.447-4.347 0-2.826-1.522-4.096-3.413-4.096Zm54.89 7.044c0 .901.437 1.618 1.645 1.618 1.427 0 2.949-1.024 3.044-3.352-.649-.095-1.365-.185-2.02-.185-1.426-.005-2.668.397-2.668 1.92Z" fill="currentColor"></path><path d="M0 0v32h111.908V0H0Zm32.56 25.426h-5.87v-7.884c0-2.423-.806-3.352-2.39-3.352-1.924 0-2.702 1.365-2.702 3.324v4.868h1.864v3.044h-5.864v-7.884c0-2.423-.806-3.352-2.39-3.352-1.924 0-2.702 1.365-2.702 3.324v4.868h2.669v3.044H6.642v-3.044h1.863v-7.918H6.642V11.42h5.864v2.11c.839-1.489 2.3-2.39 4.252-2.39 2.02 0 3.878.963 4.566 3.01.778-1.862 2.361-3.01 4.566-3.01 2.512 0 4.812 1.522 4.812 4.84v6.402h1.863v3.044h-.005Zm9.036.307c-4.314 0-7.296-2.635-7.296-7.106 0-4.096 2.484-7.481 7.514-7.481s7.481 3.38 7.481 7.29c0 4.472-3.228 7.297-7.699 7.297Zm22.578-.307H51.942l-.403-2.11 7.7-8.846h-4.376l-.621 2.17-2.888-.313.498-4.907h12.294l.313 2.11-7.767 8.852h4.533l.654-2.172 3.167.308-.872 4.908Zm7.99 0h-4.191v-5.03h4.19v5.03Zm0-8.976h-4.191v-5.03h4.19v5.03Zm2.618 8.976 6.054-21.358h3.945l-6.054 21.358h-3.945Zm8.136 0 6.048-21.358h3.945l-6.054 21.358h-3.939Zm21.486.307c-1.863 0-2.887-1.085-3.072-2.792-.805 1.427-2.232 2.792-4.498 2.792-2.02 0-4.314-1.085-4.314-4.006 0-3.447 3.323-4.253 6.518-4.253.778 0 1.584.034 2.3.124v-.465c0-1.427-.034-3.133-2.3-3.133-.84 0-1.488.061-2.143.402l-.453 1.578-3.195-.34.549-3.224c2.45-.996 3.692-1.27 5.992-1.27 3.01 0 5.556 1.55 5.556 4.75v6.083c0 .805.314 1.085.963 1.085.184 0 .375-.034.587-.095l.034 2.11a5.432 5.432 0 0 1-2.524.654Z" fill="currentColor"></path></svg></a><ul class="footer-moz-list"><li class="footer-moz-item"><a href="https://www.mozilla.org/privacy/websites/" class="footer-moz-link" target="_blank" rel="noopener noreferrer">Website Privacy Notice</a></li><li class="footer-moz-item"><a href="https://www.mozilla.org/privacy/websites/#cookies" class="footer-moz-link" target="_blank" rel="noopener noreferrer">Cookies</a></li><li class="footer-moz-item"><a href="https://www.mozilla.org/about/legal/terms/mozilla" class="footer-moz-link" target="_blank" rel="noopener noreferrer">Legal</a></li><li class="footer-moz-item"><a href="https://www.mozilla.org/about/governance/policies/participation/" class="footer-moz-link" target="_blank" rel="noopener noreferrer">Community Participation Guidelines</a></li></ul></div><div class="page-footer-legal"><p id="license" class="page-footer-legal-text">Visit<!-- --> <a href="https://www.mozilla.org" target="_blank" rel="noopener noreferrer">Mozilla Corporation’s</a> <!-- -->not-for-profit parent, the<!-- --> <a target="_blank" rel="noopener noreferrer" href="https://foundation.mozilla.org/">Mozilla Foundation</a>.<br/>Portions of this content are ©1998–<!-- -->2023<!-- --> by individual mozilla.org contributors. Content available under<!-- --> <a href="/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license">a Creative Commons license</a>.</p></div></div></footer></div><script type="application/json" id="hydration">{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Rendering and the WebXR frame animation callback","mdn_url":"/en-US/docs/Web/API/WebXR_Device_API/Rendering","locale":"en-US","native":"English (US)","sidebarHTML":"<ol><li><strong><a href=\"/en-US/docs/Web/API/WebXR_Device_API\">WebXR Device API</a></strong></li><li class=\"toggle\"><details open=\"\"><summary>Guides</summary><ol><li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Fundamentals\">Fundamentals of WebXR</a></li><li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Lifecycle\">WebXR application life cycle</a></li><li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Startup_and_shutdown\">Starting up and shutting down a WebXR session</a></li><li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Cameras\">Viewpoints and viewers: Simulating cameras in WebXR</a></li><li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Geometry\">Geometry and reference spaces in WebXR</a></li><li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Spatial_tracking\">Spaces and reference spaces: Spatial tracking in WebXR</a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Interfaces</summary><ol><li><a href=\"/en-US/docs/Web/API/XRAnchor\"><code>XRAnchor</code></a></li><li><a href=\"/en-US/docs/Web/API/XRBoundedReferenceSpace\"><code>XRBoundedReferenceSpace</code></a></li><li><a href=\"/en-US/docs/Web/API/XRCPUDepthInformation\"><code>XRCPUDepthInformation</code></a></li><li><a href=\"/en-US/docs/Web/API/XRDepthInformation\"><code>XRDepthInformation</code></a></li><li><a href=\"/en-US/docs/Web/API/XRFrame\"><code>XRFrame</code></a></li><li><a href=\"/en-US/docs/Web/API/XRInputSource\"><code>XRInputSource</code></a></li><li><a href=\"/en-US/docs/Web/API/XRInputSourceArray\"><code>XRInputSourceArray</code></a></li><li><a href=\"/en-US/docs/Web/API/XRInputSourceEvent\"><code>XRInputSourceEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/XRInputSourcesChangeEvent\"><code>XRInputSourcesChangeEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/XRPose\"><code>XRPose</code></a></li><li><a href=\"/en-US/docs/Web/API/XRReferenceSpace\"><code>XRReferenceSpace</code></a></li><li><a href=\"/en-US/docs/Web/API/XRReferenceSpaceEvent\"><code>XRReferenceSpaceEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/XRRenderState\"><code>XRRenderState</code></a></li><li><a href=\"/en-US/docs/Web/API/XRRigidTransform\"><code>XRRigidTransform</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSessionEvent\"><code>XRSessionEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSpace\"><code>XRSpace</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSystem\"><code>XRSystem</code></a></li><li><a href=\"/en-US/docs/Web/API/XRView\"><code>XRView</code></a></li><li><a href=\"/en-US/docs/Web/API/XRViewerPose\"><code>XRViewerPose</code></a></li><li><a href=\"/en-US/docs/Web/API/XRViewport\"><code>XRViewport</code></a></li><li><a href=\"/en-US/docs/Web/API/XRWebGLBinding\"><code>XRWebGLBinding</code></a></li><li><a href=\"/en-US/docs/Web/API/XRWebGLDepthInformation\"><code>XRWebGLDepthInformation</code></a></li><li><a href=\"/en-US/docs/Web/API/XRWebGLLayer\"><code>XRWebGLLayer</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Properties</summary><ol><li><a href=\"/en-US/docs/Web/API/Navigator/xr\"><code>Navigator.xr</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Methods</summary><ol><li><a href=\"/en-US/docs/Web/API/WebGLRenderingContext/makeXRCompatible\"><code>WebGLRenderingContext.makeXRCompatible()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Events</summary><ol><li><a href=\"/en-US/docs/Web/API/XRReferenceSpace/reset_event\"><code>XRReferenceSpace</code>: <code>reset</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession/end_event\"><code>XRSession</code>: <code>end</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession/inputsourceschange_event\"><code>XRSession</code>: <code>inputsourceschange</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession/select_event\"><code>XRSession</code>: <code>select</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession/selectend_event\"><code>XRSession</code>: <code>selectend</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession/selectstart_event\"><code>XRSession</code>: <code>selectstart</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSession/visibilitychange_event\"><code>XRSession</code>: <code>visibilitychange</code></a></li><li><a href=\"/en-US/docs/Web/API/XRSystem/devicechange_event\"><code>XRSystem</code>: <code>devicechange</code></a></li></ol></details></li></ol>","sidebarMacro":"DefaultAPISidebar","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Once your WebXR environment has been set up and an <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> created to represent an ongoing XR environment session, you need to provide frames of the scene to the XR device for rendering. This article covers the process of driving the frames of the XR scene to the device in the rendering loop, using the <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> to obtain an <a href=\"/en-US/docs/Web/API/XRFrame\"><code>XRFrame</code></a> object representing each frame, which is then used to prepare the framebuffer for delivery to the XR device.</p>\n<p>Before you can render the virtual environment, you need to establish a WebXR session by creating an <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> using the <a href=\"/en-US/docs/Web/API/XRSystem/requestSession\"><code>navigator.xr.requestSession()</code></a> method; you also need to associate the session with a framebuffer and perform other setup tasks. These setup tasks are described in the article <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Startup_and_shutdown\">Starting up and shutting down a WebXR session</a>.</p>"}},{"type":"prose","value":{"id":"preparing_the_renderer","title":"Preparing the renderer","isH3":false,"content":"<p>Once the XR session has been set up, with the WebGL framebuffer connected and WebGL primed with the data it needs in order to render the scene, you can set up the renderer to start running. This begins with getting the reference space in which you want to draw, with its origin and orientation set at the viewer's starting position and viewing direction. Once that's in hand, you request that the browser call your rendering function the next time it needs a framebuffer to render your scene. This is done by calling the <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> method <a href=\"/en-US/docs/Web/API/XRSession/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a>.</p>\n<p>Kicking off the renderer thus looks like this:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> worldRefSpace<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">runXR</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">xrSession</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  worldRefSpace <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> xrSession<span class=\"token punctuation\">.</span><span class=\"token function\">requestReferenceSpace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"local\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>worldRefSpace<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    viewerRefSpace <span class=\"token operator\">=</span> worldRefSpace<span class=\"token punctuation\">.</span><span class=\"token function\">getOffsetReferenceSpace</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">XRRigidTransform</span><span class=\"token punctuation\">(</span>viewerStartPosition<span class=\"token punctuation\">,</span> viewerStartOrientation<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    animationFrameRequestID <span class=\"token operator\">=</span> xrSession<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>myDrawFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>After getting a reference space for the immersive world, this creates an offset reference space representing the position and orientation of the viewer by creating an <a href=\"/en-US/docs/Web/API/XRRigidTransform\"><code>XRRigidTransform</code></a> representing that position and orientation, then calling the <a href=\"/en-US/docs/Web/API/XRReferenceSpace\"><code>XRReferenceSpace</code></a> method <a href=\"/en-US/docs/Web/API/XRReferenceSpace/getOffsetReferenceSpace\" title=\"getOffsetReferenceSpace()\"><code>getOffsetReferenceSpace()</code></a>.</p>\n<p>Then the first animation frame is scheduled by calling the <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> method <a href=\"/en-US/docs/Web/API/XRSession/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a>, providing a callback function, <code>myDrawFrame()</code>, whose job is to render the frame.</p>\n<p>Note that this code doesn't have a loop! Instead, the frame rendering code—in this case, a function named <code>myDrawFrame()</code>—is responsible for scheduling time to draw another frame by once again calling <code>requestAnimationFrame()</code>.</p>"}},{"type":"prose","value":{"id":"refresh_rate_and_frame_rate","title":"Refresh rate and frame rate","isH3":false,"content":"<p>Assuming you've called the <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> method <a href=\"/en-US/docs/Web/API/XRSession/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a> since the last time the screen refreshed, the browser will call your frame rendering callback every time it's ready to repaint your app or site window. In this context, \"repaint\" means the process of ensuring that the screen's displayed content matches what the DOM and the elements within are trying to present at the moment.</p>"}},{"type":"prose","value":{"id":"hardware_vertical_refresh_rate","title":"Hardware vertical refresh rate","isH3":true,"content":"<p>When the browser is ready to refresh the <a href=\"/en-US/docs/Web/HTML/Element/canvas\"><code>&lt;canvas&gt;</code></a> within which your WebXR content is displayed, it calls your frame rendering callback, which uses the specified timestamp and any other relevant data, such as models and textures, as well as application state, to render the scene—as it should appear at the specified time—into the WebGL backbuffer. When your callback returns, the browser transfers that backbuffer to the display or XR device, along with anything else that's changed since the last time the screen was refreshed.</p>\n<p>Historically, displays have refreshed 60 times per second. This is due to early displays using the AC electrical grid's current flow waveform, which cycles 60 times per second in the United States (50 in Europe), for timing purposes. This figure goes by a number of different names, but they're all equivalent or nearly so:</p>\n<ul>\n  <li>Refresh rate</li>\n  <li>Vertical refresh rate</li>\n  <li>Vertical blanking rate (VBL)</li>\n  <li>Vertical sync rate</li>\n</ul>\n<p>There are other similar terms used as well, but regardless of what it's called, the unit of measurement applied is the Hertz, or Hz. A display that refreshes 60 times per second has a 60 Hz refresh rate. That means that the maximum number of frames it can display in a second is 60. No matter how many frames per second you render beyond that, only 60 of them will make it to the screen in the course of a second.</p>\n<p>But not all displays run at 60 Hz; nowadays, higher performance displays are beginning to use much higher refresh rates. 120 Hz—or 120 frame per second—displays are increasingly common, for example. The browser always tries to refresh at the same rate as the display, which means that on some computers, your callback will be run a maximum of 60 times per second, while on others it might be called 90 or 120 times per second or even more, depending on the frame rate.</p>"}},{"type":"prose","value":{"id":"time_available_to_render_each_frame","title":"Time available to render each frame","isH3":true,"content":"<p>This makes using the most of the time available between frames critical. If the user's device is using a 60 Hz display, your callback will be called up to 60 times per second, and your goal is to do what you can to ensure that it doesn't get called less often than that. You achieve this by doing as much as is practicable off the main thread and by keeping your frame rendering callback as efficient as possible. The division of time into 60 Hz blocks with each block being used at least in part to render the scene is shown in the diagram below.</p>\n<p>\n  <img src=\"/en-US/docs/Web/API/WebXR_Device_API/Rendering/frames-and-refresh-rate.svg\" alt=\"Renderer execution time per frame period\" width=\"881\" height=\"179\" loading=\"lazy\">\n</p>\n<p>This is important because as the computer becomes increasingly busy, it may not be able to accurately call your callback every frame and may have to skip frames. This is called <strong>dropping frames</strong>. This happens when the amount of time it takes to render a frame exceeds the time available between frames, whether because rendering was delayed or because rendering itself took more time than was available.</p>\n<p>\n  <img src=\"/en-US/docs/Web/API/WebXR_Device_API/Rendering/dropped-frames-timing.svg\" alt=\"Renderer execution time per frame period\" width=\"881\" height=\"198\" loading=\"lazy\">\n</p>\n<p>In the diagram above, frame 3 is dropped because frame 2 did not complete rendering until after frame 3 was due to be painted. The next frame drawn will be frame 4 instead. This is another reason the timestamp passed into your rendering callback is useful. By configuring the scene based on time rather than frame number, you can ensure your rendered frames match what's expected instead of falling behind.</p>\n<p>When a frame is dropped, the contents of the affected display area don't change for that pass through the frame loop. For that reason, the occasional dropped frame isn't usually particularly noticeable, but if it starts to happen a lot—especially if several frames are dropped in a very short span of time—it can become jarring or even leave your display unusable.</p>\n<p>Fortunately, you can easily compute how much time you're allowed to use between frames as <code>1/refreshRate</code> seconds. That is, by dividing 1 by the display's refresh rate. The resulting value is the amount of time available for each frame to be rendered in order to not drop the frame. For example, a 60 Hz display has 1/60th of a second to render a single frame, or 0.0166667 seconds. And if the device's refresh rate is 120 Hz, you only have 0.00883333 seconds to render each frame if you want to avoid dropping frames.</p>\n<p>Even if the hardware is actually 120 Hz, though, you can get by with just refreshing 60 times per second anyway, and targeting that is usually a good baseline to follow. 60 FPS is already beyond the point at which most people can easily detect that the animation isn't a series of still images going by really fast. In other words, when in doubt, you can assume that the display is refreshing at 60 Hz. As long as your code is written properly, everything will be fine.</p>"}},{"type":"prose","value":{"id":"renderer_performance_concerns","title":"Renderer performance concerns","isH3":true,"content":"<p>Clearly, you have very little time to render your scene each frame. Not only that, but if your renderer itself runs longer than that amount of time, you can cause not just the frame to get dropped, but that time to be wasted entirely, blocking other code from getting to run at all for that frame.</p>\n<p>Not only that, but if your rendering crosses the vertical refresh boundary, you can wind up with a <strong>tearing</strong> effect. Tearing occurs when the display hardware starts the next refresh cycle while the previous frame is still being drawn to the screen. As a result, you wind up with the visual effect of the top part of the screen showing the new frame, while the bottom part of the frame shows some combination of the previous frame and possibly even the frame before that one.</p>\n<p>Your mission, then, is to keep your code tight and lightweight enough that you don't overrun the time available to you or otherwise cause dropped frames or excessively abuse the main thread.</p>\n<p>For these reasons, unless your renderer is fairly small and lightweight, with little to do, you should consider offloading everything you can to a worker so you can be computing the next frame while the browser handles other things. By having your computations and data ready before the frame is actually called for, you can make your site or app render much more efficiently, improving main thread performance and generally making the user experience better.</p>\n<p>Fortunately, there are some tricks you can use to further reduce your impact and optimize performance if your rendering needs are particularly heavy. See the <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Performance\">WebXR performance guide</a> for recommendations and tips that will help you ensure your performance is as good as it can be.</p>"}},{"type":"prose","value":{"id":"webxr_frames","title":"WebXR frames","isH3":false,"content":"<p>Your frame rendering callback function receives as input two parameters: the time to which the frame corresponds, and an <a href=\"/en-US/docs/Web/API/XRFrame\"><code>XRFrame</code></a> object describing the state of the scene as of that time.</p>"}},{"type":"prose","value":{"id":"the_optics_of_3d","title":"The optics of 3D","isH3":true,"content":"<p>We have two eyes for a reason: by having two eyes, each inherently sees the world from a slightly different angle. Since they're a known, fixed distance apart, our brains can do basic geometry and trigonometry and figure out the 3D nature of reality from that information. We also make use of perspective, size differences, and even our understanding of how things usually look to figure out the details of that third dimension. These factors, among others, are the source of our <a href=\"https://en.wikipedia.org/wiki/Depth_perception\" class=\"external\" target=\"_blank\">depth perception</a>.</p>\n<p>To create the illusion of three dimensions when rendering graphics, we need to simulate as many of these factors as we can. The more of these we simulate—and the more accurately we do so—the better we are able to trick the human brain into perceiving our images in 3D. The advantage to XR is that not only can we use the classic monocular techniques to simulate 3D graphics (perspective, size, and simulated parallax), but we can also simulate binocular vision—that is, vision using two eyes—by rendering the scene twice for each frame of animation—once for each eye.</p>\n<p>The typical human's <a href=\"https://en.wikipedia.org/wiki/Pupillary_distance\" class=\"external\" target=\"_blank\">pupillary distance</a>—the distance between the centers of the pupils—is between 54 and 74 millimeters (0.054 to 0.074 meters). So if the center of the viewer's head is located at <code>[0.0, 2.0, 0.0]</code> (about two meters above ground level at the center of the space horizontally), we first need to render the scene from, say, <code>[-0.032, 2.0, 0.0]</code> (32mm to the left of center) and then render it again at <code>[0.032, 2.0, 0.0]</code> (32mm right of center.) This way, we place the positions of the viewer's eyes at an average human pupillary distance of 64mm.</p>\n<p>That distance (or whatever pupillary distance the XR system is configured to use) is enough to allow our minds to see just enough difference due to retinal disparity (the difference in what each retina sees) and the parallax effect to allow our brains to calculate the distance to and depth of objects, thus enabling us to perceive three dimensions despite our retinas only being 2D surfaces.</p>\n<p>This is illustrated in the diagram below, in which we see how each eye perceives a die located directly in front of the viewer. While this diagram exaggerates the effect in some respects for illustrative purposes, the concept is the same. Each eye sees an area whose boundaries make up an arc in front of the eye. Because each eye is offset to one side or the other of the head's centerline, and each eye sees about the same field of view, the result is that each eye sees a slightly different part of the world in front of it, and from a slightly different angle.</p>\n<p>\n  <img src=\"/en-US/docs/Web/API/WebXR_Device_API/Rendering/binocular-vision.svg\" alt=\"Diagram showing how binocular vision works\" width=\"550\" height=\"720\" loading=\"lazy\">\n</p>\n<p>The left eye sees the die from a little bit to the left of center, and the right eye sees it from a bit to the right of center. As a result, the left eye sees just a little bit more of the left side of the object and a little bit less of the right, and vice versa. These two images are focused onto the retinas and the resulting signal transmitted over the optic nerves to the brain's visual cortex, located at the back of the occipital lobe.</p>\n<p>The brain takes those signals from the left and right eyes and constructs a single, unified, 3D image of the world in the viewer's brain, and that image is what is seen. And because of those differences between what is seen by the left eye versus the right eye, the brain is able to infer a great deal of information about how deep the object is, its size, and more. By combining that inferred depth information with other cues such as perspective, shadows, memories of what these relationships mean, and so forth, we can figure out a great deal about the world around us.</p>"}},{"type":"prose","value":{"id":"frames_poses_views_and_framebuffers","title":"Frames, poses, views, and framebuffers","isH3":true,"content":"<p>Once you have an <code>XRFrame</code> representing the state of the scene at a moment in time, you need to determine the positions of objects within the scene relative to the viewer so that you can render them. The viewer's position and orientation relative to a reference space is represented by an <a href=\"/en-US/docs/Web/API/XRViewerPose\"><code>XRViewerPose</code></a> obtained by calling the <a href=\"/en-US/docs/Web/API/XRFrame\"><code>XRFrame</code></a> method <a href=\"/en-US/docs/Web/API/XRFrame/getViewerPose\" title=\"getViewerPose()\"><code>getViewerPose()</code></a>.</p>\n<p>The <code>XRFrame</code> doesn't directly keep track of the positions or orientations of the objects in your world. Instead, it offers a way to convert positions and orientations into the scene's coordinate system, and it collects the viewer's position and orientation data from the XR hardware, converts it into the reference space you've configured, and delivers it to your frame rendering code with a timestamp. You use that timestamp and your own data to determine how to render the scene.</p>\n<p>After rendering the scene twice—once into the left half of the framebuffer and once into the right half of the framebuffer—the framebuffer is sent to the XR hardware, which displays each half of the framebuffer to the corresponding eye. This is often (but not always) done by drawing the image to a single screen and using lenses to transfer the correct half of that image to each eye.</p>\n<p>You can learn more about how 3D is represented by WebXR in <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Cameras#representing_3d_with_webxr\">Representing 3D with WebXR</a>.</p>"}},{"type":"prose","value":{"id":"drawing_the_scene","title":"Drawing the scene","isH3":false,"content":"<p>When the time comes to prepare the framebuffer so the browser can paint the next frame of your scene, the function you provided to <code>requestAnimationFrame()</code> is invoked. It receives as input the time at which the frame being drawn and an <a href=\"/en-US/docs/Web/API/XRFrame\"><code>XRFrame</code></a> object providing details about the state of the scene for the frame you need to render.</p>\n<p>Ideally, you want this code to be fast enough that it can maintain a 60 FPS frame rate, or as close to that as possible, remembering that there's more going on than just your code in this one function. You need to make sure that the main thread doesn't need to run for more time per frame than the duration of the frame itself.</p>"}},{"type":"prose","value":{"id":"a_basic_renderer","title":"A basic renderer","isH3":true,"content":"<p>In this version of the WebXR rendering callback, we use a very straightforward approach that works great for relatively simple projects. This pseudocode outlines that process:</p>\n<pre class=\"brush: plain notranslate\">for each view in the pose's views list:\n  get the WebXR GL layer's viewport\n  set the WebGL viewport to match\n  for each object in the scene\n    bindProgram()\n    bindVertices()\n    bindMatrices()\n    bindUniforms()\n    bindBuffers()\n    bindTextures()\n    drawMyObject()\n</pre>\n<p>Put, this form of renderer is using <strong>view-first order</strong>. Each of the two views making up the XR device's display are rendered back to back, where every object is drawn on one view before rendering the same set of objects on the other view. As a result, there's a good bit of replicated effort, since much of the data needed to draw an object winds up getting sent to the GPU twice per frame. However, it simplifies porting existing WebGL code and is frequently good enough to do the job, so we'll look at this method first.</p>\n<p>See <a href=\"#optimizing_by_rendering_in_object-first_order\">Optimizing by rendering in object-first order</a> for an alternative approach that renders each object twice back-to-back, once for each eye, before moving on to the next object that makes up the scene for that frame; that is, rendering in <strong>object-first order</strong>.</p>\n<h4 id=\"sample_rendering_callback\">Sample rendering callback</h4>\n<p>Let's take a look at some real code that follows this basic pattern. Since in the example above we gave this function the name <code>myDrawFrame()</code>, we'll continue to use that here.</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> lastFrameTime <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myDrawFrame</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">currentFrameTime<span class=\"token punctuation\">,</span> frame</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> session <span class=\"token operator\">=</span> frame<span class=\"token punctuation\">.</span>session<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> viewerPose<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Schedule the next frame to be painted when the time comes.</span>\n\n  animationFrameRequestID <span class=\"token operator\">=</span> session<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>myDrawFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Get an XRViewerPose representing the position and</span>\n  <span class=\"token comment\">// orientation of the viewer. If successful, render the</span>\n  <span class=\"token comment\">// frame.</span>\n\n  viewerPose <span class=\"token operator\">=</span> frame<span class=\"token punctuation\">.</span><span class=\"token function\">getViewerPose</span><span class=\"token punctuation\">(</span>viewerRefSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>viewerPose<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> glLayer <span class=\"token operator\">=</span> session<span class=\"token punctuation\">.</span>renderState<span class=\"token punctuation\">.</span>baseLayer<span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">bindFrameBuffer</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">.</span><span class=\"token constant\">FRAMEBUFFER</span><span class=\"token punctuation\">,</span> glLayer<span class=\"token punctuation\">.</span>framebuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Start by erasing the color and depth framebuffers.</span>\n\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clearDepth</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">.</span><span class=\"token constant\">COLOR_BUFFER_BIT</span> <span class=\"token operator\">|</span> gl<span class=\"token punctuation\">.</span><span class=\"token constant\">DEPTH_BUFFER_BIT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Compute the time elapsed since the last frame was rendered.</span>\n    <span class=\"token comment\">// Use this value to ensure your animation runs at the exact</span>\n    <span class=\"token comment\">// rate you intend.</span>\n\n    <span class=\"token keyword\">const</span> deltaTime <span class=\"token operator\">=</span> currentFrameTime <span class=\"token operator\">-</span> lastFrameTime<span class=\"token punctuation\">;</span>\n    lastFrameTime <span class=\"token operator\">=</span> currentFrameTime<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Now call the scene rendering code once for each of</span>\n    <span class=\"token comment\">// the session's views.</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> view <span class=\"token keyword\">of</span> viewerPose<span class=\"token punctuation\">.</span>views<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> viewport <span class=\"token operator\">=</span> glLayer<span class=\"token punctuation\">.</span><span class=\"token function\">getViewport</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      gl<span class=\"token punctuation\">.</span><span class=\"token function\">viewport</span><span class=\"token punctuation\">(</span>viewport<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> viewport<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> viewport<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> viewport<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">myDrawSceneIntoView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> deltaTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>The <code>myDrawFrame()</code> function grabs the <a href=\"/en-US/docs/Web/API/XRSession\"><code>XRSession</code></a> from the <a href=\"/en-US/docs/Web/API/XRFrame\"><code>XRFrame</code></a> object specified by the <code>frame</code> parameter, then calls the session's <a href=\"/en-US/docs/Web/API/XRSession/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a> method to immediately schedule the rendering of the next frame. This ensures we get into the queue right away, allowing the rest of the time spent in this iteration of the <code>myDrawFrame()</code> function to count toward the timing of drawing the next frame.</p>\n<p>We then get the <a href=\"/en-US/docs/Web/API/XRViewerPose\"><code>XRViewerPose</code></a> object that describes the viewer's pose—their position and orientation—using the frame's <a href=\"/en-US/docs/Web/API/XRFrame/getViewerPose\" title=\"getViewerPose()\"><code>getViewerPose()</code></a> method, passing in the viewer's reference space from the <code>viewerRefSpace</code> previously obtained <a href=\"#preparing_the_renderer\">while setting up the WebXR session</a>.</p>\n<p>With the viewer's pose in hand, we can then begin to render the frame. The first step is to obtain access to the framebuffer into which the WebXR device wants the frame drawn; this is done by getting the target WebGL layer from the session's <a href=\"/en-US/docs/Web/API/XRSession/renderState\" title=\"renderState\"><code>renderState</code></a> object's <a href=\"/en-US/docs/Web/API/XRRenderState/baseLayer\" title=\"baseLayer\"><code>baseLayer</code></a> property, then getting the <a href=\"/en-US/docs/Web/API/XRWebGLLayer/framebuffer\" title=\"framebuffer\"><code>framebuffer</code></a> from that <a href=\"/en-US/docs/Web/API/XRWebGLLayer\"><code>XRWebGLLayer</code></a> object. We then call <a href=\"/en-US/docs/Web/API/WebGLRenderingContext/bindFramebuffer\"><code>gl.bindFrameBuffer()</code></a> to bind that framebuffer as the target for all upcoming drawing commands.</p>\n<p>The next step is to erase the framebuffer. While you can in theory skip this step—<em>if and only if your rendering code is guaranteed to write every single pixel in the framebuffer</em>—it's generally safest to just go ahead and clear it before you begin to draw, unless you need to eke out every ounce of performance you can and know you're touching all the pixels anyway. The background color is set to fully opaque black using <a href=\"/en-US/docs/Web/API/WebGLRenderingContext/clearColor\"><code>gl.clearColor()</code></a>; the clear depth is set to 1.0 by calling <a href=\"/en-US/docs/Web/API/WebGLRenderingContext/clearDepth\"><code>gl.cleardepth()</code></a>, in order to clear all pixels regardless of how far away the object they're part of is; and finally, the frame's pixel and depth buffers are both erased by calling <a href=\"/en-US/docs/Web/API/WebGLRenderingContext/clear\"><code>gl.clear()</code></a>, passing in a bit mask in which both <code>COLOR_BUFFER_BIT</code> and <code>DEPTH_BUFFER_BIT</code> are set.</p>\n<p>Since WebXR uses a single framebuffer for every view, with viewports upon the view being used to separate each eye's viewpoint within the framebuffer, we only need to clear a single framebuffer rather than cleaning it for each eye (or other viewpoints, if any) individually.</p>\n<p>Next, the time elapsed since the previous frame was rendered is calculated by subtracting from the current time as specified by the <code>currentFrameTime</code> parameter the saved time at which the last frame was rendered, <code>lastFrameTime</code>. The result is a <a href=\"/en-US/docs/Web/API/DOMHighResTimeStamp\"><code>DOMHighResTimeStamp</code></a> value indicating the number of milliseconds that have elapsed since the last frame was rendered. We can use this value while drawing the scene to ensure we move everything the appropriate distance given the true elapsed time, rather than assuming that the callback will be fired at a consistent frame rate. This elapsed time is saved in the variable <code>deltaTime</code>, and the value of <code>lastFrameTime</code> is replaced with this frame's time, ready to compute the differential for the next frame.</p>\n<p>It's now time to actually render the scene for each eye. We iterate over the views within the viewer poses's <a href=\"/en-US/docs/Web/API/XRViewerPose/views\" title=\"views\"><code>views</code></a> array. For each of these <a href=\"/en-US/docs/Web/API/XRView\"><code>XRView</code></a> objects representing an eye's perspective on the scene, we need to begin by limiting drawing to the area of the framebuffer which represents the current eye's visible image.</p>\n<p>We begin by preparing WebGL to render the eye's contents by getting the viewport that restricts drawing to the area within the framebuffer that's reserved for the current eye's image by calling the <a href=\"/en-US/docs/Web/API/XRWebGLLayer\"><code>XRWebGLLayer</code></a> method <a href=\"/en-US/docs/Web/API/XRWebGLLayer/getViewport\" title=\"getViewport()\"><code>getViewport()</code></a>. We then set the WebGL viewport to match, passing in the X and Y origin of the viewport along with its width and height into <a href=\"/en-US/docs/Web/API/WebGLRenderingContext/viewport\"><code>gl.viewport()</code></a>.</p>\n<p>Finally, we call our method <code>myDrawSceneIntoView()</code> to actually use WebGL to render the scene. Into this, we pass the <a href=\"/en-US/docs/Web/API/XRView\"><code>XRView</code></a> representing the eye we're drawing for (in order to perform perspective mapping and the like) and <code>deltaTime</code>, so the scene drawing code can accurately represent the elapsed time when determining the positions of objects moving over time.</p>\n<p>When the loop that's iterating over the views ends, every image required to represent the scene to the viewer has been rendered, and upon return, the framebuffer makes its way through the GPU and eventually to the XR device's display or displays. Since we called <a href=\"/en-US/docs/Web/API/XRSession/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a> at the top of the function, our callback will be invoked once again when it's time to render the next frame of the scene's animation.</p>\n<h4 id=\"drawbacks_to_this_approach\">Drawbacks to this approach</h4>\n<p>Since it's important to minimize how much time you spend in this function as much as possible, the more time you spend handling state changes, the less time you have to actually draw things. This technique works very well for a small number of objects, but because it has to re-bind all the data for each object twice (once for the left eye, and once for the right), you're spending a lot of time adjusting the state, uploading buffers and textures, and so forth. In the next section, we look at an altered approach that reduces these state changes substantially, providing a potentially much faster rendering approach, especially as your object count goes up.</p>"}},{"type":"prose","value":{"id":"optimizing_by_rendering_in_object-first_order","title":"Optimizing by rendering in object-first order","isH3":true,"content":"<p>An advantage of WebXR's approach of using a single WebGL framebuffer to contain both the left and right eye's views in a single framebuffer makes it possible to substantially improve rendering performance by rearranging the order in which things are done. Instead of setting up the viewport for a given view (such as the left eye), then rendering every object visible to the left eye, one by one, reconfiguring buffers for each object as you go, you can instead render each object twice in a row, once for each eye, thereby only needing to set up the buffers, uniforms, and so forth once for both eyes.</p>\n<p>The resulting pseudocode looks like this:</p>\n<pre class=\"brush: plain notranslate\">for each object in the scene\n  bindProgram()\n  bindUniforms()\n  bindBuffers()\n  bindTextures()\n  for each view in the pose's views list\n    get the XRWebGLLayer's viewport\n    set the WebGL viewport to match\n    bindVertices()\n    bindMatrices()\n    drawMyObject()\n</pre>\n<p>By changing things up in this way, we only bind programs, uniforms, buffers, textures, and potentially other things once per frame instead of twice for each object found in the scene. This reduces overhead by a potentially very large margin.</p>"}},{"type":"prose","value":{"id":"limiting_the_frame_rate","title":"Limiting the frame rate","isH3":true,"content":"<p>If you need to intentionally cap your frame rate in order to establish a baseline frame rate to try to maintain while allowing more time for other code to run, you can do so by skipping frames intentionally, on a timed basis.</p>\n<p>For example, to reduce the frame rate by 50%, just skip every other frame:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> tick <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">drawFrame</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">time<span class=\"token punctuation\">,</span> frame</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  animationFrameRequestID <span class=\"token operator\">=</span> frame<span class=\"token punctuation\">.</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>drawFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>tick <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/* Draw the scene */</span>\n  <span class=\"token punctuation\">}</span>\n  tick<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>This version of the rendering callback maintains a <code>tick</code> counter. The frame is only rendered if <code>tick</code> is an even number value. This way, only every other frame gets rendered.</p>\n<p>You can similarly render every fourth frame using <code>!(tick % 4)</code>, and so forth.</p>"}},{"type":"prose","value":{"id":"matching_your_animation_to_the_elapsed_time","title":"Matching your animation to the elapsed time","isH3":true,"content":"<p>The rendering callback receives a <code>time</code> parameter for a good reason. This <a href=\"/en-US/docs/Web/API/DOMHighResTimeStamp\"><code>DOMHighResTimeStamp</code></a> value is a floating-point value indicating the time at which the frame was scheduled for rendering. Because the execution of your callback is not going to happen at precise 1/60th of a second intervals—and, indeed, could happen at other rates if the user's display has a different frame rate—you can't rely on the simple fact that your code is running to assume that it's been 1/60th of a second since the last frame.</p>\n<p>For that reason, you need to use the timestamp provided to ensure your animation renders at precisely the desired speed. To do so, the first thing you need to do is to compute the time that has elapsed since the last frame was rendered:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> lastFrameTime <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">drawFrame</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">time<span class=\"token punctuation\">,</span> frame</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// schedule next frame, prepare the buffer, etc.</span>\n\n  <span class=\"token keyword\">const</span> deltaTime <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>time <span class=\"token operator\">-</span> lastFrameTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.001</span><span class=\"token punctuation\">;</span>\n  lastFrameTime <span class=\"token operator\">=</span> time<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> view <span class=\"token keyword\">of</span> pose<span class=\"token punctuation\">.</span>views<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/* render each view */</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>This maintains a global (or an object property) called <code>lastFrameTime</code> which contains the previous frame's time of rendering. In this case, since the time values are stored in milliseconds, we multiply by 0.001 to convert the time into seconds. In some cases, this saves time later. In other situations, you need the time in milliseconds, so you wouldn't need to change anything.</p>\n<p>With the elapsed time in hand, your rendering code has the means to compute just how much every moving object has moved in the time elapsed. For instance, if an object is rotating, you might apply the rotation like this:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> xDeltaRotation <span class=\"token operator\">=</span>\n  xRotationDegreesPerSecond <span class=\"token operator\">*</span> <span class=\"token constant\">RADIANS_PER_DEGREE</span> <span class=\"token operator\">*</span> deltaTime<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> yDeltaRotation <span class=\"token operator\">=</span>\n  yRotationDegreesPerSecond <span class=\"token operator\">*</span> <span class=\"token constant\">RADIANS_PER_DEGREE</span> <span class=\"token operator\">*</span> deltaTime<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> zDeltaRotation <span class=\"token operator\">=</span>\n  zRotationDegreesPerSecond <span class=\"token operator\">*</span> <span class=\"token constant\">RADIANS_PER_DEGREE</span> <span class=\"token operator\">*</span> deltaTime<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>This computes the amount by which the object has rotated around each of the three axes since the last time the frame was drawn. Without this, the shape would rotate by the given amount every frame, regardless of the elapsed time. This could cause substantial stutter in many cases.</p>\n<p>The same concept applied for objects that are moving rather than rotating:</p>\n<div class=\"code-example\"><p class=\"example-header\"><span class=\"language-name\">js</span></p><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> xDistanceMoved <span class=\"token operator\">=</span> xSpeedPerSecond <span class=\"token operator\">*</span> deltaTime<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> yDistanceMoved <span class=\"token operator\">=</span> ySpeedPerSecond <span class=\"token operator\">*</span> deltaTime<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ZDistanceMoved <span class=\"token operator\">=</span> zSpeedPerSecond <span class=\"token operator\">*</span> deltaTime<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p><code>xSpeedPerSecond</code>, <code>ySpeedPerSecond</code>, and <code>zSpeedPerSecond</code> each contain that axis's component of the object's velocity. In other words, <code>[xDistanceMoved, yDistanceMoved, zDistanceMoved]</code> is a vector representing the velocity of the object.</p>"}},{"type":"prose","value":{"id":"additional_tasks_related_to_animating_the_scene","title":"Additional tasks related to animating the scene","isH3":false,"content":"<p>There are, of course, other things that probably need to happen each pass through the renderer. Two of the most common are <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Inputs\">handling of user inputs</a> and performing updates to the positions of objects (or the viewer) based on known factors, such as those user control states or known animation paths of the objects in the scene.</p>"}},{"type":"prose","value":{"id":"handling_user_control_inputs","title":"Handling user control inputs","isH3":true,"content":"<p>There are three methods by which users might provide input while using a WebXR application. First, WebXR supports directly handling inputs from the controllers which are integrated with the XR hardware itself. These input sources may include devices such as hand controllers, optical tracking systems, accelerometers and magnetometers, and other devices of that nature.</p>\n<p>The second type of input is a gamepad that's connected through the XR system. This uses interfaces inherited from the <a href=\"/en-US/docs/Web/API/Gamepad_API\">Gamepad API</a> but you interact with them through WebXR.</p>\n<p>The third and final type of input is the traditional non-XR input device such as keyboards, mice, trackpads, touch screens, and non-XR gamepads and joysticks.</p>\n<p>Orientation and position information that can be collected from the XR hardware directly is applied automatically. Thus it's the other kinds of input that you need to handle yourself:</p>\n<ul>\n  <li>Pointing device target and button presses</li>\n  <li>Gamepad inputs</li>\n  <li>Non-XR input device inputs</li>\n</ul>\n<p>To learn more about how to handle user inputs while presenting a scene using WebXR, see the article <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Inputs\">Inputs and input sources</a>.</p>"}},{"type":"prose","value":{"id":"updating_object_positions","title":"Updating object positions","isH3":true,"content":"<p>Most (though not all) scenes include some form of animation, in which things move and react to one another in appropriate ways.</p>\n<p>For example, a virtual reality or augmented reality game might have enemy non-player characters being controlled by the computer and moving around the scene. Not only are their locations in the world changing over time, but each NPC likely has body parts or components that are moving in relation to one another. Arms and legs swing as a creature walks, heads bob and turn, hair bounces and sways, torsos expand and contract as the character breathes.</p>\n<p>In addition, there may be objects and structures in motion. In a sports game, there may be a ball arcing through the air, its movement needing to be simulated. In racing games there may be cars or other vehicles, with moving parts to animate including the wheels. If there's water in the scene, it needs ripples or waves to look realistic. Parts of structures may be moving, such as doors, walls and floors (for some types of games), and so forth.</p>\n<p>Another common source of motion is the player themselves. After interpreting inputs from the controls (both XR-affiliated and otherwise), you need to apply those changes to the scene in order to simulate the user's movement. See the article <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Movement_and_motion\">Movement, orientation, and motion</a> for details and a thorough example of how this works.</p>"}},{"type":"prose","value":{"id":"next_steps","title":"Next steps","isH3":false,"content":"<p>Once you've got your renderer written—or at least got something that works, even if it's not finished—you can begin to deal with the camera and its movement through the scene. This is covered in our article about <a href=\"/en-US/docs/Web/API/WebXR_Device_API/Cameras\">viewpoints and viewers</a> in WebXR.</p>"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n  <li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Geometry\">Geometry and reference spaces in WebXR</a></li>\n  <li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Spatial_tracking\">Spatial tracking in WebXR</a></li>\n  <li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Cameras\">Viewpoints and viewers: Simulating cameras in WebXR</a></li>\n  <li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Movement_and_motion\">Movement, orientation, and motion: A WebXR example</a></li>\n  <li><a href=\"/en-US/docs/Web/API/WebXR_Device_API/Performance\">WebXR performance guide</a></li>\n</ul>"}}],"toc":[{"text":"Preparing the renderer","id":"preparing_the_renderer"},{"text":"Refresh rate and frame rate","id":"refresh_rate_and_frame_rate"},{"text":"WebXR frames","id":"webxr_frames"},{"text":"Drawing the scene","id":"drawing_the_scene"},{"text":"Additional tasks related to animating the scene","id":"additional_tasks_related_to_animating_the_scene"},{"text":"Next steps","id":"next_steps"},{"text":"See also","id":"see_also"}],"summary":"Once your WebXR environment has been set up and an XRSession created to represent an ongoing XR environment session, you need to provide frames of the scene to the XR device for rendering. This article covers the process of driving the frames of the XR scene to the device in the rendering loop, using the XRSession to obtain an XRFrame object representing each frame, which is then used to prepare the framebuffer for delivery to the XR device.","popularity":0.0006,"modified":"2023-07-25T00:27:48.000Z","source":{"folder":"en-us/web/api/webxr_device_api/rendering","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/api/webxr_device_api/rendering/index.md","last_commit_url":"https://github.com/mdn/content/commit/592f6ec42e54981b6573b58ec0343c9aa8cbbda8","filename":"index.md"},"short_title":"Rendering and the WebXR frame animation callback","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebXR_Device_API","title":"WebXR Device API"},{"uri":"/en-US/docs/Web/API/WebXR_Device_API/Rendering","title":"Rendering and the WebXR frame animation callback"}],"pageTitle":"Rendering and the WebXR frame animation callback - Web APIs | MDN","noIndexing":false}}</script></body></html>