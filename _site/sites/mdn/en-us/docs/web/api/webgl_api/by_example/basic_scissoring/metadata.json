{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{"macros":[{"id":"macro0","fixable":false,"suggestion":null,"explanation":"/en-US/docs/Glossary/RGBA does not exist","name":"MacroBrokenLinkError","error":{},"errorStack":"Error: /en-US/docs/Glossary/RGBA does not exist\n    at Object.recordNonFatalError (file:///Users/jason/Code/yari/kumascript/src/render.ts:88:13)\n    at Object.smartLink (file:///Users/jason/Code/yari/kumascript/src/api/web.ts:121:29)\n    at eval (\"/Users/jason/Code/yari/kumascript/macros/Glossary.ejs\":22:18)\n    at Glossary (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:703:17)\n    at /Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:260:40\n    at new Promise (<anonymous>)\n    at tryHandleCache (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:258:14)\n    at exports.renderFile (/Users/jason/Code/yari/node_modules/ejs/lib/ejs.js:491:10)\n    at Templates.render (file:///Users/jason/Code/yari/kumascript/src/templates.ts:55:40)\n    at render (file:///Users/jason/Code/yari/kumascript/src/render.ts:181:56)","offset":6,"line":12,"column":265,"macroName":"Glossary","sourceContext":"  | <p>This is a simple demonstration of a rendering with {{domxref(\"WebGLRenderingContext.scissor\",\"scissor()\")}}.</p>\n  | <p>Although the {{domxref(\"WebGLRenderingContext.clear\",\"clear()\")}} drawing command writes the clear color (set by {{domxref(\"WebGLRenderingContext.clearColor\",\"clearColor()\")}}) to all pixels in the drawing buffer, {{domxref(\"WebGLRenderingContext.scissor\",\"scissor()\")}} defines a mask that only allows pixels inside the specified rectangular area to be updated.</p>\n> | <p>This is a good opportunity to talk about the difference between pixels and <em>fragments</em>. A pixel is a picture element (in practice, a point) on the screen, or a single element of the drawing buffer, that area in memory that holds your pixel data (such as {{Glossary(\"RGBA\")}} color components). A <em>fragment</em> refers to the pixel while it is being handled by the {{Glossary(\"WebGL\")}} pipeline.</p>\n                                                                                                                                                                                                                                                                            ^\n  | <p>The reason for this distinction is that fragment color (and other fragment values, such as depth) may be manipulated and changed several times during graphics operations before finally being written to the screen. We have already seen how fragment color changes during graphics operations, by applying {{domxref(\"WebGLRenderingContext.colorMask()\",\"color masking\", \"\", 1)}}. In other cases, the fragments may be discarded altogether (so the pixel value is not updated), or it may interact with the already existing pixel value (such as when doing color blending for non-opaque elements in the scene).</p>\n  | <p>Here we see another example of the distinction between fragments and pixels. Scissoring is a distinct stage in the {{Glossary(\"WebGL\")}}/{{Glossary(\"OpenGL\")}} graphics pipeline (it occurs after color clearing, but before color masking). Before the actual pixels are updated, fragments must go through the scissor test. If the fragments pass the scissor test, they continue down the graphics pipeline, and the corresponding pixels are updated on the screen. If they fail the test, they are immediately discarded, no further processing occurs, and pixels are not updated. Because only fragments within the specified rectangular area successfully pass the scissor test, only pixels inside that area are updated, and we get a rectangle on the screen.</p>","fatal":false,"filepath":"/Users/jason/Code/content/files/en-us/web/api/webgl_api/by_example/basic_scissoring/index.md","macroSource":"{{Glossary(\"RGBA\")}}"}]},"title":"Basic scissoring","mdn_url":"/en-US/docs/Web/API/WebGL_API/By_example/Basic_scissoring","locale":"en-US","native":"English (US)","summary":"In this example, we see how to draw simple rectangles and squares using WebGL scissoring operations. Scissoring establishes a clipping region outside which drawing will not occur.","popularity":0.0009,"modified":"2023-07-07T07:19:19.000Z","source":{"folder":"en-us/web/api/webgl_api/by_example/basic_scissoring","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/api/webgl_api/by_example/basic_scissoring/index.md","last_commit_url":"https://github.com/mdn/content/commit/acfe8c9f1f4145f77653a2bc64a9744b001358dc","filename":"index.md"},"short_title":"Basic scissoring","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebGL_API","title":"WebGL: 2D and 3D graphics for the web"},{"uri":"/en-US/docs/Web/API/WebGL_API/By_example","title":"WebGL by example"},{"uri":"/en-US/docs/Web/API/WebGL_API/By_example/Basic_scissoring","title":"Basic scissoring"}],"pageTitle":"Basic scissoring - Web APIs | MDN","noIndexing":false,"hash":"0e2d959daca7606ec25e1787dcfaab6bc221a01570190a56f729f9e4a19e3ee0"}